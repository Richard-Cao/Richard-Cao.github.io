<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android纯本地安全存储方案]]></title>
    <url>%2F2019%2F03%2F14%2FAndroid-Local-Security-Storage%2F</url>
    <content type="text"><![CDATA[背景在业务中，我们可能需要面对在Android本地存储用户token、email等敏感数据。本文将讲述一种安全系数较高的Android本地存储方案。思路整个方案的核心思路围绕KeyStore展开，如果不太了解KeyStore的小伙伴，请先阅读Android密钥库系统。由于KeyStore在Android 6.0前后差异较大，并且Android 4.3以下系统并不支持KeyStore，方案需要根据不同的Android版本做不同的处理，以及需要提供降级方案。加解密算法采用AES/CBC/PKCS7Padding。Android 6.0或更高版本系统这种情况下方案最简单，随机生成128位AES key和iv，key存储在KeyStore中，设置alias，iv存储在SharedPreferences中。需要加解密的时候通过alias从KeyStore中取key，从SharedPreferences中取iv。首先初始化KeyStore：123456789101112private static final String ANDROID_KEY_STORE = "AndroidKeyStore";// 初始化if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR2) &#123; try &#123; mKs = KeyStore.getInstance(ANDROID_KEY_STORE); mKs.load(null); &#125; catch (Exception e) &#123; // 降级方案 return; &#125;&#125;然后就是生成key了，这里贴出核心代码：12345678910111213141516171819202122232425262728293031323334353637@RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)public void createNewKeys(Context context, String alias) throws KeyStoreException, NoSuchProviderException, NoSuchAlgorithmException, InvalidAlgorithmParameterException, IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchPaddingException &#123; try &#123; if (TextUtils.isEmpty(alias) || mKs.containsAlias(alias)) &#123; return; &#125; &#125; catch (NullPointerException e) &#123; return; &#125; // 省略无关紧要的代码... AlgorithmParameterSpec spec; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) &#123; // 这里是第二种情况，下面会详细讲 &#125; else &#123; // generate aes key KeyGenerator kGenerator = KeyGenerator.getInstance( KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEY_STORE); spec = new KeyGenParameterSpec.Builder(alias, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT) .setCertificateSubject(new X500Principal("CN=" + alias)) .setDigests(KeyProperties.DIGEST_SHA256, KeyProperties.DIGEST_SHA512) .setBlockModes(KeyProperties.BLOCK_MODE_CBC) .setKeySize(128) .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7) .setRandomizedEncryptionRequired(false) .build(); kGenerator.init(spec); kGenerator.generateKey(); // generate aes iv and save // 省略无关紧要的代码... &#125;&#125;那加解密的时候怎么取得key呢？很简单：1Key key = mKs.getKey(alias, null);取出来key作为Cipher的参数在init的时候传入就可以了，剩下的就是常规的加解密，这里就不贴代码了。Android 4.3 - 5.1由于KeyStore在Android 4.3 - 5.1版本不支持AES算法，所以需要随机生成RSA的key pair，算法采用RSA/ECB/PKCS1Padding，设置alias并存储在KeyStore中。然后随机生成128位AES key和iv，使用前面生成的RSA公钥加密key，key和iv一起存储在SharedPreferences中。需要加解密的时候，从SharedPreferences中读取加密后的key，从KeyStore中取出RSA私钥，使用RSA私钥解密得到真正的AES key，再进行加解密。这里贴出第二种情况下的代码：1234567891011121314151617181920212223242526272829303132333435private static final String TYPE_RSA = "RSA";// 下面这段代码就是在if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M)条件中的// generate rsa key pairKeyPairGenerator kpGenerator = KeyPairGenerator.getInstance(TYPE_RSA, ANDROID_KEY_STORE);spec = new KeyPairGeneratorSpec.Builder(context) .setAlias(alias) .setSubject(new X500Principal("CN=" + alias + " ,O=Android Authority")) .setSerialNumber(BigInteger.valueOf(1337)) .build();kpGenerator.initialize(spec);try &#123; kpGenerator.generateKeyPair(); // generate aes key and iv generateAESKeyAndIV(alias);&#125; catch (IllegalStateException e) &#123; // keystore locked // I guess no lock screen pin password // https://issuetracker.google.com/issues/37051017 // 降级方案&#125; catch (IllegalArgumentException e) &#123; // When keystore generates the key pair, it generates a self signed cert. // The ASN1 parser used internally by Android Keystore doesn't correctly take in // the locale and it causes the failures for device locale with language from // right to left // https://issuetracker.google.com/issues/37095309 // 降级方案&#125; catch (RuntimeException e) &#123; // Sometimes throw RuntimeException (Samsung Android 4) // error:0D07207B:asn1 encoding routines:ASN1_get_object:header too long // I guess maybe related to keystore being locked // Demote temporarily // 降级方案&#125;代码一贴，一切就明朗起来了。这里要注意处理代码中catch的几种异常，会在某些三星手机或者其他手机上出现。那这里怎么取key呢？123456789private static final String AES_CBC_PKCS7_PADDING = "AES/CBC/PKCS7Padding";// 从SharedPreferences中取出RSA加密过的aes keyString encryptAESKey = xxxbyte[] aesKey = decryptRSA(alias, encryptAESKey); // 进行RSA解密if (aesKey == null) &#123; return null;&#125;return new SecretKeySpec(aesKey, AES_CBC_PKCS7_PADDING);取出来key作为Cipher的参数在init的时候传入就可以了，剩下的就是常规的加解密，这里就不贴代码了。这种情况下，加解密会比第一种情况下耗时，因为需要经历一次RSA的解密操作。Android 4.3以下版本以及降级方案KeyStore不支持Android 4.3以下的系统。这里提供一种简单思路：可以写一个so库，通过种子字符串生成固定的128位AES key和iv，将iv存储在SharedPreferences中。在so库中内置应用签名，在JNI_OnLoad函数中进行签名校验，检验不通过直接Crash。生成的key不保存在本地，需要加解密的时候调用so方法实时获取key。注：种子字符串是一串随机的字符串，内置在so库中，用于通过计算生成key。如果签名验证失败，就无法生成key。它不是绝对安全的，只是尽可能保证安全。补充建议提供root检测工具，如果检测到设备已经root，直接提示用户存在安全风险。总结围绕KeyStore的方案大致思路讲完了，其中一些坑也是线上踩了总结出来的，核心代码其实很少，思路最关键，欢迎交流。]]></content>
      <categories>
        <category>踩坑总结</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Android本地拒绝服务漏洞的追根溯源]]></title>
    <url>%2F2018%2F08%2F03%2FAndroid-Service-Reject%2F</url>
    <content type="text"><![CDATA[背景由于一些xxxxoooo的原因，我需要修复一个跨进程Service可能会被外部传入intent数据导致拒绝服务的问题。当被告知这个问题的时候，我是一脸懵逼的。复现这个问题的测试代码如下：12345Intent i = new Intent();i.setClassName("我要调起的应用的包名", "我要调起的对外导出的Service");// TestSerializeObj是我构造的一个只实现了序列化接口的空类i.putExtra("瞎写的测试数据", new TestSerializeObj());startService(i);我看到的报错信息大概是这样的：java.lang.RuntimeException: Parcelable encountered ClassNotFoundException reading a Serializable object，堆栈崩在了Service的onStartCommand方法中。于是我开始对着onStartCommand里的一小段代码冥思苦想：1234567891011121314151617@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; // 省略无关代码 ... if (intent == null) &#123; intent = new Intent(); // 省略无关代码 ... intent.putExtra("aa", "bb"); &#125; else if (intent.getAction() == null) &#123; // 省略无关代码 ... intent.putExtra("aa", "cc"); &#125; // 省略无关代码 ...&#125;和Intent相关的就这些了。根据我看到的堆栈崩溃行数，就是intent.putExtra方法出现了ClassNotFoundException。实在搞不清原因，只能追踪一下看看了。追根溯源首先是putExtra方法：1234567public @NonNull Intent putExtra(String name, String value) &#123; if (mExtras == null) &#123; mExtras = new Bundle(); &#125; mExtras.putString(name, value); return this;&#125;继续看putString方法：1234public void putString(@Nullable String key, @Nullable String value) &#123; unparcel(); mMap.put(key, value);&#125;map的put应该没什么问题，那有可能有问题的就是unparcel方法了。继续看下去：1234567891011121314151617181920212223/* package */ void unparcel() &#123; synchronized (this) &#123; final Parcel parcelledData = mParcelledData; // 省略无关代码 ... try &#123; parcelledData.readArrayMapInternal(map, N, mClassLoader); &#125; catch (BadParcelableException e) &#123; if (sShouldDefuse) &#123; Log.w(TAG, "Failed to parse Bundle, but defusing quietly", e); map.erase(); &#125; else &#123; throw e; &#125; &#125; finally &#123; mMap = map; parcelledData.recycle(); mParcelledData = null; &#125; // 省略无关代码 ... &#125;&#125;如果是这个方法出问题的话，问题应该出在readArrayMapInternal方法上。继续查看这个方法（这个方法在Parcel类中）：123456789101112131415/* package */ void readArrayMapInternal(ArrayMap outVal, int N, ClassLoader loader) &#123; // 省略无关代码 ... while (N &gt; 0) &#123; // 省略无关代码 ... String key = readString(); Object value = readValue(loader); // 省略无关代码 ... N--; &#125; outVal.validate();&#125;可以看到，这里做的操作实际上是循环读值。因为是ClassNotFoundException，所以问题应该出在和ClassLoader有关的方法上，这里唯一使用了ClassLoader的就是readValue了。那么看一下readValue方法做了什么：123456789101112public final Object readValue(ClassLoader loader) &#123; int type = readInt(); switch (type) &#123; // 省略无关代码 ... case VAL_SERIALIZABLE: return readSerializable(loader); // 省略无关代码 ... &#125;&#125;由于我测试代码是构造了一个空实现的Serializable对象塞进来，所以相关的方法应该是readSerializable，继续看readSerializable做了什么事：1234567891011121314151617181920212223242526272829303132private final Serializable readSerializable(final ClassLoader loader) &#123; String name = readString(); // 省略无关代码 ... byte[] serializedData = createByteArray(); ByteArrayInputStream bais = new ByteArrayInputStream(serializedData); try &#123; ObjectInputStream ois = new ObjectInputStream(bais) &#123; @Override protected Class&lt;?&gt; resolveClass(ObjectStreamClass osClass) throws IOException, ClassNotFoundException &#123; // try the custom classloader if provided if (loader != null) &#123; Class&lt;?&gt; c = Class.forName(osClass.getName(), false, loader); if (c != null) &#123; return c; &#125; &#125; return super.resolveClass(osClass); &#125; &#125;; return (Serializable) ois.readObject(); &#125; catch (IOException ioe) &#123; throw new RuntimeException("Parcelable encountered " + "IOException reading a Serializable object (name = " + name + ")", ioe); &#125; catch (ClassNotFoundException cnfe) &#123; throw new RuntimeException("Parcelable encountered " + "ClassNotFoundException reading a Serializable object (name = " + name + ")", cnfe); &#125;&#125;重头戏来了！崩溃日志在这里出现了！这里通过传进来的ClassLoader寻找是否有我传进来的空数据类，显然不可能有，于是ClassNotFoundException就非常稳定的出现了。至此，问题的根源已经找到了。总结修复方式也简单，在对外暴露（跨进程）的Activity、Service或者Broadcast等需要用到intent的地方，不管是putXXX还是getXXX（getXXX也需要执行unparcel方法）操作，都加上try-catch抓住这个错误就可以了。说实话，这个问题我第一次遇到，这是一个安全性问题，算是让我记忆深刻了，以后不能再踩这个坑了。]]></content>
      <categories>
        <category>踩坑总结</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端开发的未来]]></title>
    <url>%2F2018%2F07%2F25%2FMobile-Future%2F</url>
    <content type="text"><![CDATA[我是一名Android开发者。从去年下半年开始，就开始听到各种言论，例如“Android开发凉凉”、“移动端开发没出路了赶紧转行”、“要被XXX替代了”等等，充分反映了大家焦虑的心态。移动端开发真的要凉凉了吗？我也经常和朋友聊起这个话题，今天我决定写下自己的一些看法，供大家参考。现状移动端开发的现状是什么？我们可以从自己写的代码中寻找线索。以Android为例，很多大公司的移动端开发者写的最多的代码是这样的：123LinearLayout layout = new LinearLayout();layout.addView(xxxx);...或者也许是这样的：12345678910111213141516171819202122232425public class XXXView extends RelativeLayout &#123; public XXXView(Context context) &#123; this(context, null); &#125; public XXXView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public XXXView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView(); &#125; private void initView() &#123; LayoutInflater.from(getContext()).inflate(R.layout.xxxlayout, this, true); ... &#125; public void setData(XXX xxx) &#123; ... &#125;&#125;又或者是对着xml标签做出各种骚操作——UI开发。没错，如今移动端技术栈已经愈发趋于成熟完善，对业务来说，就连大公司的工程师也是在做UI的展示逻辑。大公司产品相对比较完善，后端管控了大部分业务逻辑，客户端做的就是取到后端的数据，然后通过setText(xxx)展示出来，然后通过接口返回的Boolean值来判断View显示还是隐藏。我听到很多人说，工作几年感觉自己没什么提升，天天都在堆代码，随便找个刚毕业的学生也能分分钟替代自己，于是就很焦虑。那对于工作几年的人来说，要想尽可能不让自己过早的被替代、被淘汰，就需要选一个有潜力的有前景的领域深挖。那么移动端开发的未来在哪里？动态化在聊动态化之前，我们先聊聊Android的插件化。前两年，插件化火起来了。为什么火？因为可以实现Android应用不发版本的同时动态上线需求，同时热修复还可以动态的修复线上出现的bug。但是插件化存在最大的问题是什么呢？兼容性。Android机型太多太复杂，插件化框架难免会涉及到系统API的hook，兼容性问题就出现了，开发者会看到莫名其妙的错误上报上来却束手无策。随着Android版本的迭代更新，插件化这条路越来越不好走，Android P给了开发者们一个信号：别随便hook系统API了，Google要开始收口整顿了。插件化这条路注定无法一直走下去，于是开发者们另辟蹊径。最开始是继续用H5混合开发的方式，例如老牌Hybrid框架Cordova，但是性能不尽人意。这时候Facebook开发出了一个跨时代的框架：React-Native。它提供了一个全新的思路：通过jscore进行js解析，使用原生的View进行渲染，提供桥机制调用原生的能力。React-Native是第一个真正的高性能的动态化框架，它的出现让Web前端和客户端的界限迅速变得模糊。随之而来的是各大公司的自研框架，例如阿里巴巴的Weex和美团点评的Picasso框架。React-Native只提供了Android和iOS的双端支持，Weex扩展了思路，提供的Web端的支持，一个是React语法糖，一个是Vue语法糖。Picasso又不一样，Picasso是纯TS，DSL语法树，写法实在太简单，又准备在三端的基础上提供小程序端的支持。今年GMTC大会，Flutter发布了第一个预览版，阿里巴巴闲鱼团队已经在闲鱼APP中使用了Flutter技术。Flutter三年前开始开发，直到今年才有第一个beta版本。通过Dart编写APP，然后编译成机器码同时运行在Android和iOS上，做到了原生跨平台，Hot Reload，性能很不错，可定制性也非常强，连封装的系统层Dart代码都能改。提供了Web、iOS、Android、React-Native开发者学习Flutter的入门文档，也是今年移动端少数的几个比较火的热点之一。它的思路不同于React-Native，是一种全新的思路，目前我对Flutter持乐观态度。支付宝的动态方式不同于以上所有，它是完全基于自己的H5容器进行Hybrid开发，不过由于内核也是自研的（UC内核），所以性能各方面都比原生的WebView好，支付宝里非常多的页面都是基于H5容器开发的，包括支付宝小程序，这也算是一种动态化的方式吧，只不过研发成本太高：自研WebView内核。目前来看，动态化的三驾马车已经初步形成：React-Native为首的jscore（v8）桥通信动态化方案自研WebView内核，H5容器化方案Flutter（我觉得Flutter正在发力争取第三驾马车的位置）动态化改变了移动开发的方式，模糊了Web前端和客户端的界限，让越来越多的人认识了什么是“大前端”。如果有经验的开发者们对这个方向进行深入研究，五年内，应该不会被淘汰了（笑）。移动端机器学习毫无疑问，移动端机器学习从去年年底就开始火起来了，TensorFlow也推出了移动端框架，很多应用都开始在移动端部署机器学习模型，例如相机类应用（faceu）、电商类应用（唯品会）等，包括离线的机器学习。如果深挖这个方向，我觉得十年内不会被淘汰。当然了，难度也不小。AR &amp; VR从支付宝的AR抢红包、QQ的AR踢球等玩法被越来越多的人体验，AR走进了人们的视野。对于广告引流玩法来说，AR无疑是能带来巨大收益的。月初大众点评亲子上线了“亲子奇妙日”活动，就是基于大头儿子小头爸爸的AR玩法。那么开发AR引擎的移动开发者自然成了香饽饽，目前AR主要应用的领域还是广告变现，不过很多公司也找到了AR的一些落地场景，比如卖家具的电商公司可以通过AR技术让用户在购买之前就能看到实物在自己家里到底能不能放得下，这能极大的提升用户的购买体验。如果是研究OpenGL、计算机图形学的移动开发者，可以往AR引擎开发方向发展，非常有前景。VR同理。移动端音视频这个领域最火的产品当之无愧是抖音了，就连我自己都天天刷抖音。除了抖音，还有各大视频应用，都需要音视频开发领域的专业开发人员，图像处理、滤镜、裁剪等等骚操作都是需要专业的音视频开发知识才能做出来的，研究OpenGL、计算机图形学的移动开发者在这个领域也有很大的优势。据我所知，这方面人才现在缺口依然很大，各大公司求贤若渴，如果在这方面有经验并且愿意深挖的同学，自然是各大公司的香饽饽啦。移动端区块链区块链，今年最火的技术没有之一。从人人都在谈比特币到人人都在谈区块链，可以看出区块链技术已经被越来越多人熟知。无数区块链公司如雨后春笋般的冒出，连大公司们也按捺不住开始涉足区块链领域。对于移动端来说，区块链应用最多的还是数字钱包。但是未来移动端区块链一定会有更多的落地应用，例如Status。区块链今年大火，移动端的区块链应用还没开始火，但是也不远了。如果有移动开发同学对区块链方向感兴趣的，可以开始研究起来了。如果要学习智能合约开发的同学，我推荐一个非常好的网站：Cryptozombies，绝对是入门solidity智能合约开发的精品。目前移动端的区块链人才还不多，各大公司也没有在招，但是两三年内，应该就会爆发了，现在还在探索落地场景的阶段，也给了对区块链技术感兴趣的移动开发同学学习的时间。改变世界的技术了解一下？移动基础框架UI未来可能都会被动态化技术接管，但是移动基础框架不会。但凡要开发一个APP，网络请求、日志处理、数据库处理、缓存、Push等框架都是不可或缺的，这部分和UI关系不大，又是APP的命脉所在。只要APP存在，基础框架就存在。有同学可能要说了，我用okhttp分分钟写一个网络请求出来，没错，这是okhttp已经帮我们做好了很多事。什么是框架？用一句话总结，我的理解就是：一种可以让能力差别较大的开发者写出功能、性能差不多的代码的库不知道大家能不能理解这种说法，我举个例子：如果使用HttpUrlConnection来写网络请求，可能不同能力的开发者写出来的代码不一样，网络请求的性能和效果也不一样。但是如果使用了okhttp库，只要看一看okhttp的文档，新手和老手写出来的代码估计差不多，性能和效果也差不多，这就是框架做出的最大的贡献。在这些框架的基础上，P5写的代码可能和P6、P7区别不会多大。然而，这些框架总要有人开发，开源的框架往往不能满足公司业务的需求，需要自研基础框架。尤其是BAT、TMD六家公司，移动端框架有大部分都是自研的，越来越多的公司也开始自研，所以如果是在这个方向有经验的移动开发者，在APP被淘汰之前，应该都不会被淘汰。这方面对移动开发者的知识深度和广度都要求相对较高，需要沉淀和学习。Android工具类应用这个就比较特殊了，这类应用我举个例子：360手机助手。对于Android用户来说，清理内存、清理垃圾等已经成为了一种习惯，这方面应用的开发自然是不可少的，而且非常考验对Android知识的深度，你们懂得。结语上面六个（七个）移动端开发方向，是我总结出来的有潜力有前景的方向，各位移动开发同学可以参考，可以选择一个方向进行深挖，相信一定会有收获。嘴上焦虑是没有意义的，最好的办法就是付出行动。积土成山，风雨兴焉；积水成渊，蛟龙生焉；积善成德，而神明自得，圣心备焉。故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Mobile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种高效通用的字符串前置匹配方法]]></title>
    <url>%2F2018%2F07%2F20%2FNew-Efficient-String-StartsWith%2F</url>
    <content type="text"><![CDATA[现状一般情况下，我们使用字符串的前置匹配方法，如果要做的通用一些，忽略大小写，可能会这么写：12345678public boolean startsWithIgnoreCase(String str, String prefix) &#123; if (!TextUtils.isEmpty(str) &amp;&amp; !TextUtils.isEmpty(prefix)) &#123; String tempS = str.toLowerCase(); String tempP = prefix.toLowerCase(); return tempS.startsWith(tempP); &#125; return false;&#125;从功能上说，这么写当然没问题。但是，我们忽略了一个问题：toLowerCase(toUpperCase)方法是耗时的。为什么耗时？以toLowerCase为例：1234567891011121314151617181920212223242526272829public static String toLowerCase(Locale locale, String s) &#123; // Punt hard cases to ICU4C. // Note that Greek isn't a particularly hard case for toLowerCase, only toUpperCase. String languageCode = locale.getLanguage(); if (languageCode.equals("tr") || languageCode.equals("az") || languageCode.equals("lt")) &#123; return ICU.toLowerCase(s, locale); &#125; String newString = null; for (int i = 0, end = s.length(); i &lt; end; ++i) &#123; char ch = s.charAt(i); char newCh; if (ch == LATIN_CAPITAL_I_WITH_DOT || Character.isHighSurrogate(ch)) &#123; // Punt these hard cases. return ICU.toLowerCase(s, locale); &#125; else if (ch == GREEK_CAPITAL_SIGMA &amp;&amp; isFinalSigma(s, i)) &#123; newCh = GREEK_SMALL_FINAL_SIGMA; &#125; else &#123; newCh = Character.toLowerCase(ch); &#125; if (ch != newCh) &#123; if (newString == null) &#123; newString = StringFactory.newStringFromString(s); &#125; newString.setCharAt(i, newCh); &#125; &#125; return newString != null ? newString : s;&#125;会遍历字符串并且重新赋值给newString，最终调用的是Character.toLowerCase方法：12345678910public static int toLowerCase(int codePoint) &#123; // Optimized case for ASCII if ('A' &lt;= codePoint &amp;&amp; codePoint &lt;= 'Z') &#123; return (char) (codePoint + ('a' - 'A')); &#125; if (codePoint &lt; 192) &#123; return codePoint; &#125; return toLowerCaseImpl(codePoint);&#125;最后这里的toLowerCaseImpl就是真正实现的方法，这是一个Native方法，也是由C/C++完成的。toLowerCaseImpl效率高，然而在调用toLowerCaseImpl之前的操作，会耗时。那我们最开始的startsWithIgnoreCase方法的性能瓶颈就在这里了。如果想要减少耗时，应该怎么办呢？分析耗时关键点：toLowerCase。这个方法，当然是没什么替代的空间， 只能另辟蹊径。关于String的忽略大小写比对，除了toLowerCase和toUpperCase之后再比对，我们还会想到一个方法：equalsIgnoreCase。这个方法的效率会比先toLowerCase之后再比对的效率高。为什么呢？12345678910111213141516public boolean equalsIgnoreCase(String string) &#123; if (string == this) &#123; return true; &#125; if (string == null || count != string.count) &#123; return false; &#125; for (int i = 0; i &lt; count; ++i) &#123; char c1 = charAt(i); char c2 = string.charAt(i); if (c1 != c2 &amp;&amp; foldCase(c1) != foldCase(c2)) &#123; return false; &#125; &#125; return true;&#125;并不会对字符串进行全拷贝，foldCase就直接调用到上文中Character.toLowerCase方法，最后调用到toLowerCaseImpl方法。实现说了这么多，肯定有小伙伴会问：我们不是在聊字符串前置匹配吗？equals速度快了和前置匹配有什么关系呢？让我们想想前置匹配的逻辑：处理好忽略大小写后的字符串，进行startsWith操作，是不是可以等同于，字符串str截取从下标为0到prefix.length的位置，这部分前置字符串再和prefix进行equalsIgnoreCase？如果str的长度小于等于prefix的长度，其实startsWith和equals是一样的。逻辑已经梳理清楚了，那么就简单了，动手写一下新的忽略字符串大小写的前置匹配通用方法：123456789public static boolean startsWithIgnoreCase(String str, String prefix) &#123; if (!TextUtils.isEmpty(str) &amp;&amp; !TextUtils.isEmpty(prefix)) &#123; if (str.length() &gt; prefix.length()) &#123; str = str.substring(0, prefix.length()); &#125; return str.equalsIgnoreCase(prefix); &#125; return false;&#125;方法写好了，让我们写个Demo验证一下是否真的有优化效果吧。验证上Demo代码：123456789101112131415long start = System.currentTimeMillis();for (int i = 0; i &lt; 10000; i++) &#123; startsWithIgnoreCase("sdasdasdasdasdasdhgjhgkturyetrtuuuii", "sdasdasdasdasdasdhgjhgkturyetrtuuuii");&#125;long diff = System.currentTimeMillis() - start;Log.d("test", "test startsWithIgnoreCase: " + diff + "ms");long startNew = System.currentTimeMillis();for (int i = 0; i &lt; 10000; i++) &#123; startsWithIgnoreCaseNew("sdasdasdasdasdasdhgjhgkturyetrtuuuii", "sdasdasdasdasdasdhgjhgkturyetrtuuuii");&#125;long diffNew = System.currentTimeMillis() - startNew;Log.d("test", "test startsWithIgnoreCaseNew: " + diffNew + "ms");这里的startsWithIgnoreCaseNew方法就是新实现的startsWithIgnoreCase方法。当str和prefix完全一样的时候，验证结果如下：如果在str和prefix中随机加一些大写字符，验证结果如下：高下立判！高下立判！高下立判！]]></content>
      <categories>
        <category>踩坑总结</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Synchronized对象锁的一个优化细节]]></title>
    <url>%2F2018%2F01%2F09%2FJava-Synchronized-Object-Lock%2F</url>
    <content type="text"><![CDATA[背景大家在使用synchronized关键字的时候，可能经常会这么写：123synchronized (this) &#123; ...&#125;它的作用域是当前对象，锁的就是当前对象，谁拿到这个锁谁就可以运行它所控制的代码。当有一个明确的对象作为锁时，就可以这么写，但是当没有一个明确的对象作为锁，只想让一段代码同步时，可以创建一个特殊的变量（对象）来充当锁：123456789public class Demo &#123; private final Object lock = new Object(); public void methonA() &#123; synchronized (lock) &#123; ... &#125; &#125;&#125;这样写没问题。但是用new Object()作为锁对象是否是一个最佳选择呢？于是我好奇的搜索了一下，发现了这么一篇文章：object-vs-byte0-as-lock，大意就是用new byte[0]作为锁对象更好，会减少字节码操作的次数。由于这篇文章已经比较老了，为了确定到底如何，我还是决定手动验证一下。准备工作首先，我写了两个非常简单的java类作为Demo使用：1234// Demo.javapublic class Demo &#123; private final Object lock = new Object();&#125;1234// Demo_2.javapublic class Demo_2 &#123; private final byte[] lock = new byte[0];&#125;我电脑上java的版本是：123java version &quot;1.8.0_91&quot;Java(TM) SE Runtime Environment (build 1.8.0_91-b14)Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)JVM首先，要验证一下编译成JVM字节码是不是真的如上文所述。于是分别编译出两个java文件的class文件：12javac Demo.javajavac Demo_2.java然后使用javap命令查看Demo的字节码：1234567891011121314▶ javap -c DemoCompiled from &quot;Demo.java&quot;public class Demo &#123; public Demo(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: aload_0 5: new #2 // class java/lang/Object 8: dup 9: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 12: putfield #3 // Field lock:Ljava/lang/Object; 15: return&#125;再查看Demo_2的字节码：12345678910111213▶ javap -c Demo_2Compiled from &quot;Demo_2.java&quot;public class Demo_2 &#123; public Demo_2(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: aload_0 5: iconst_0 6: newarray byte 8: putfield #2 // Field lock:[B 11: return&#125;可以看出，new byte[0]确实比new Object()少4条字节码操作。再计算一下内存占用，参考JAVA 对象大小一文可以计算出：在64位jvm默认开启UseCompressedOops的情况下（Java 1.6.0_23版本开始就默认开启了），一个空对象，不包含任何成员变量，大小16字节，一个byte[0]数组，大小也是16字节，是相等的。于是验证了上面的结论：用new byte[0]作为锁对象是优于new Object()的。在日常的java开发中，可以注意到这个细节的点来优化代码。But，我是个Android开发，Android的虚拟机不是jvm，而是dvm。dvm相比jvm做了很多优化，那么在dvm上，结论还是一样的吗？带着这个问题，我又进一步做了验证。DVM要想得到dvm的字节码，就需要使用Android SDK自带的dx工具将class文件转换为dex格式并dump出dex文件的内容。我使用了build-tools/26.0.2目录中的dx工具。12▶ ~/developer/android-sdk-macosx/build-tools/26.0.2/dx --dex --verbose --dump-to=Demo.dex.txt --verbose-dump Demo.classprocessing Demo.class...同理，Demo_2也是这条命令，只是将Demo换成Demo2而已。这样就得到了两个class文件对应的dvm字节码。先来看看Demo的：12345678...0000ee: 2200 0100 | 0003: new-instance v0, java.lang.Object // type@00010000f2: 7010 0100 0000| 0005: invoke-direct &#123;v0&#125;, java.lang.Object.&lt;init&gt;:()V | // method@00010000f8: 5b10 0000 | 0008: iput-object v0, v1, Demo.lock:Ljava/lang/Object; | // field@00000000fc: 0e00 | 000a: return-void...再来看看Demo_2的：123456...0000f6: 1200 | 0003: const/4 v0, #int 0 // #00000f8: 2300 0300 | 0004: new-array v0, v0, byte[] // type@00030000fc: 5b10 0000 | 0006: iput-object v0, v1, Demo_2.lock:[B // field@0000000100: 0e00 | 0008: return-void...对比一下发现，指令都是4条。Dalvik字节码是以16位为单元（双字节码），java字节码以1字节为单元（单字节码）。可以看出，Demo这部分字节码一共8个单元即16字节，而Demo_2这部分字节码一共6个单元即12字节，new Object()比new byte[0]多了2个单元，意味着只是多分配了2个虚拟寄存器而已。内存占用方面同上。那么可以得出结论了：在Android编程中，使用new Object()或者new byte[0]作为对象锁差别不大。总结虽然最后发现经过dvm的优化，用new Object()还是new byte[0]作为锁对象差别不大，但是总归追究了这个问题得出了结论，并且也验证了在jvm下用new byte[0]作为锁对象是更好的选择，也了解了java对象的内存占用，dvm和jvm的区别以及dx工具的使用，以后再看到dx工具dump出的dex文件内容就不会感到陌生了。]]></content>
      <categories>
        <category>踩坑总结</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins中使用Appium的最佳姿势]]></title>
    <url>%2F2017%2F11%2F03%2FIntegration-of-Appium-with-Jenkins%2F</url>
    <content type="text"><![CDATA[最近在公司内部申请了一台云主机当做我们组自己的slave机器，于是把之前从北京侧同事那边借的Job迁移过来，appium相关的环境要全部重新配置。上次同事帮了我很多忙，所以我并不太清楚Jenkins这块儿到底应该怎么配置，这次是完全自己走了一遍坑，记录一下遇到的问题。撰写本文时笔者的云主机上一些环境版本：Linux：Ubuntu 14.04npm：5.4.2node：6.11.5appium：1.7.1环境变量在配好slave机器之后，已经有了一些默认的环境变量（我的机器上是Android环境），要配置appium，我们需要npm、node套件。我是一个比较保守的人，于是选择了node 6和npm 5，在Ubuntu上安装了这些，然后1npm install appium -g等待安装完毕之后，基本的appium环境就具备了。于是我跑了一遍脚本，GG。看了报错发现appium、ruby等都没识别出来，对比之前的机器我发现因为环境变量没有新增，我的机器上Jenkins相关的环境变量配置在/data/config/config.properties文件中，我添加了node、ruby路径然后配置了PATH变量，重启了机器，再跑一遍Job，发现appium、ruby等识别出来了。注：网络环境不好的话，大概率可能会出来类似这样的log：12info UiAutomator2 downloading UiAutomator2 Server APK v0.1.9 : https://github.com/appium/appium-uiautomator2-server/releases/download/v0.1.9/appium-uiautomator2-server-v0.1.9.apkinfo UiAutomator2 downloading UiAutomator2 Server test APK v0.1.9 : https://github.com/appium/appium-uiautomator2-server/releases/download/v0.1.9/appium-uiautomator2-server-debug-androidTest.apk然后一直卡在这里不动了。那解决方式就简单了，手动下载这俩app，然后放到对应的目录~/.nvm/versions/node/v6.11.5/lib/node_modules/appium/node_modules/appium-uiautomator2-driver/uiautomator2/中就行。如果没有uiautomator2子目录，就新建一个。进程守护在配置好appium环境之后，运行1appium就可以启动appium进程。本地这么做当然没什么问题，但是在Jenkins上这么做就有问题了。首先，我们要在一个Job里跑脚本，当运行appium之后，整个会话就被堵塞了，后面的脚本没法执行了，所以我们一定要让appium server跑在后台，同时还要管理appium的日志已经启动/停止appium server。方法一我们都知道，Linux系统中有一个Upstart服务管理程序，它可以让一些服务在后台运行并且管理，相关的服务我们可以在/etc/init/目录下找到。既然它可以让服务在后台运行，我们也可以使用它来管理我们的appium服务。有了这个思路，我们只需要在/etc/init/目录下新增一个配置文件appium.conf：12345678stop on shutdownrespawnscript . /data/config/config.properties cd /data/log/appium exec appium -a 127.0.0.1 --session-override &gt; appium.logend script这里提一点，在Jenkins机器上跑appium，要想远程连接真机，需要指定ip为127.0.0.1，本机直接运行appium默认的ip是0.0.0.0，这个在Jenkins机器上是无法连接远程真机的。这个配置文件写好保存好之后，我们运行起来就简单了，这里只需要了解三个命令：12# 启动appium服务start appium12# 停止appium服务stop appium12# 查看appium服务状态status appium然后appium的log被重定向到一个自定义的log文件中，就可以在Jenkins Job里输出相关的log内容了。在运行start appium之后，服务在后台运行，Job就可以继续执行后续脚本，达到了一个Job运行appium测试的目的。我目前使用的就是这个方法。方法二appium服务是一个node server，既然这样，那可以选取node应用的相关工具来管理。这里推荐pm2，一个非常强大的node服务管理工具，安装也非常简单：1npm install pm2 -g使用的话，如果我们要达到上面方法一的效果，启动appium的命令应该这么写：1pm2 start appium -- -a 127.0.0.1其中–代表了后面跟着appium识别的参数，这里并没有重定向log文件，因为pm2已经具备了比较强大的日志管理功能。在~/.pm2/logs/目录下，启动appium之后会生成2个日志文件，一个error的日志，一个普通的log日志，这个就非常强大了，同时提供了1pm2 flush可以用来清空日志，重新收集。停止服务也非常简单：1pm2 stop appium其他相关用法请自行Google。记得使用pm2启动服务，一定要设置相应的环境变量，否则GG！环境检查运行appium脚本之前，我们需要通过appium-doctor工具检查运行环境是否都具备了。安装appium-doctor很简单：1npm install appium-doctor -g然后检查一下环境：1appium-doctor踩坑集锦在Jenkins机器上，Job运行起来之后，报了一个大大的ERROR：1An unknown server-side error occurred while processing the command. Original error: JAVA_HOME is not set currently. Please set JAVA_HOME. (Selenium::WebDriver::Error::UnknownError)我就纳闷了，appium-doctor都没问题，怎么跑起来有问题了呢？我又观察了log输出，发现了存在问题的log：1[UiAutomator2] Unable to remove port forward &apos;Error executing adbExec. Original error: &apos;Command &apos;/data/tools/android_sdk/platform-tools//adb -P 5037 -s 172.22.36.116\:7401 forward --remove tcp\:8200&apos; exited with code 1&apos;; Stderr: &apos;error: listener &apos;tcp:8200&apos; not found&apos;; Code: &apos;1&apos;&apos;没看懂什么意思，于是我去Google搜了一波，搜到的信息大多都和我实际遇到的问题无关，包括JAVA_HOME没设置的问题，也没收获。于是我又仔细观察了log，发现了一个疑点：123[debug] [UiAutomator2] Deleting UiAutomator2 session[debug] [UiAutomator2] Deleting UiAutomator2 server session[UiAutomator2] Did not get confirmation UiAutomator2 deleteSession worked; Error was: Error: Trying to proxy a session command without session id这个log看起来是有问题的，于是我又去Google搜了一波，依然没什么收获，我以为我的机器有毒，我就回到自己电脑上更新了一下appium，然后本地跑了一波，居然报了同样的错误！这我就不能忍了，本机为什么报这样的错误？既然搜不到，也只能在日志里寻找蛛丝马迹。本机报错的时候，我发现多了一些日志输出：1234567891011121314151617181920212223242526272829303132333435[MJSONWP] Encountered internal error running command: Error: JAVA_HOME is not set currently. Please set JAVA_HOME. at getJavaHome (../../lib/helpers.js:110:9) at getJavaForOs (../../lib/helpers.js:99:17) at ADB.callee$0$0$ (../../../lib/tools/apk-signing.js:106:16) at tryCatch (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:67:40) at GeneratorFunctionPrototype.invoke [as _invoke] (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:315:22) at GeneratorFunctionPrototype.prototype.(anonymous function) [as next] (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:100:21) at invoke (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:136:37) at enqueueResult (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:185:17) at Promise.F (/usr/local/lib/node_modules/appium/node_modules/.1.2.7@core-js/library/modules/$.export.js:30:36) at AsyncIterator.enqueue (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:184:12) at AsyncIterator.prototype.(anonymous function) [as next] (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:100:21) at Object.runtime.async (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:209:12) at ADB.callee$0$0 [as checkApkCert] (../../../lib/tools/apk-signing.js:106:13) at UiAutomator2Server.checkAndSignCert$ (../../lib/uiautomator2.js:114:33) at tryCatch (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:67:40) at GeneratorFunctionPrototype.invoke [as _invoke] (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:315:22) at GeneratorFunctionPrototype.prototype.(anonymous function) [as next] (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:100:21) at invoke (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:136:37) at enqueueResult (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:185:17) at Promise.F (/usr/local/lib/node_modules/appium/node_modules/.1.2.7@core-js/library/modules/$.export.js:30:36) at AsyncIterator.enqueue (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:184:12) at AsyncIterator.prototype.(anonymous function) [as next] (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:100:21) at Object.runtime.async (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:209:12) at UiAutomator2Server.checkAndSignCert (../../lib/uiautomator2.js:114:15) at UiAutomator2Server.signAndInstall$ (../../lib/uiautomator2.js:108:16) at tryCatch (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:67:40) at GeneratorFunctionPrototype.invoke [as _invoke] (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:315:22) at GeneratorFunctionPrototype.prototype.(anonymous function) [as next] (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:100:21) at invoke (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:136:37) at enqueueResult (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:185:17) at Promise.F (/usr/local/lib/node_modules/appium/node_modules/.1.2.7@core-js/library/modules/$.export.js:30:36) at AsyncIterator.enqueue (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:184:12) at AsyncIterator.prototype.(anonymous function) [as next] (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:100:21) at Object.runtime.async (/usr/local/lib/node_modules/appium/node_modules/.5.8.24@babel-runtime/regenerator/runtime.js:209:12)这段日志显然是非常有用的，我摘取了日志中非常重要的几条信息：我发现出现这个报错的场景是重新安装UiAutomator2相关的2个apk时候报的，大概猜测在重新安装的时候对这两个apk进行了签名相关的校验报错主要的信息应该在uiautomator2.js、tools/apk-signing.js和helpers.js中，这些文件都在appium的node_modules中获得了这些非常有用的信息之后，我打算查一下代码，看看到底是什么问题。首先看uiautomator2.js，这个文件在appium的appium-uiautomator2-driver依赖库中，定位到出问题的代码：12345678910111213async signAndInstall (apk, apkPackage, timeout = SERVER_INSTALL_RETRIES * 1000, test = false) &#123; await this.checkAndSignCert(apk, apkPackage); await this.adb.install(apk, true, timeout); logger.info(`Installed UiAutomator2 server$&#123;test ? ' test' : ''&#125; apk`);&#125;async checkAndSignCert (apk, apkPackage) &#123; let signed = await this.adb.checkApkCert(apk, apkPackage); if (!signed) &#123; await this.adb.sign(apk); &#125; return !signed;&#125;checkAndSignCert就是检查并且签名的操作，这部分代码定位到之后，下一步寻找的就是tools/apk-signing.js，这个文件在appium的appium-adb依赖库中，定位到出问题的代码：1234567891011121314151617181920apkSigningMethods.checkApkCert = async function (apk, pkg) &#123; const java = getJavaForOs(); if (!(await fs.exists(apk))) &#123; log.debug(`APK doesn't exist. $&#123;apk&#125;`); return false; &#125; if (this.useKeystore) &#123; return await this.checkCustomApkCert(apk, pkg); &#125; log.debug(`Checking app cert for $&#123;apk&#125;.`); try &#123; await exec(java, ['-jar', path.resolve(this.helperJarPath, 'verify.jar'), apk]); log.debug("App already signed."); await this.zipAlignApk(apk); return true; &#125; catch (e) &#123; log.debug("App not signed with debug cert."); return false; &#125;&#125;;继续定位，根据log发现是getJavaForOs方法出了问题，这个方法在helpers.js中，正好与log中下一步的报错信息吻合：12345678function getJavaForOs () &#123; const sep = path.sep; let java = `$&#123;getJavaHome()&#125;$&#123;sep&#125;bin$&#123;sep&#125;java`; if (system.isWindows()) &#123; java = java + '.exe'; &#125; return java;&#125;通过日志我们可以看到是getJavaHome方法报错了，继续定位：123456function getJavaHome () &#123; if (process.env.JAVA_HOME) &#123; return process.env.JAVA_HOME; &#125; throw new Error("JAVA_HOME is not set currently. Please set JAVA_HOME.");&#125;到这里，精准定位问题了，throw的就是最开始的报错信息。原来appium-adb拿到java环境变量是通过process.env获取的，而process.env是node获取环境变量的手段，也就是说，如果没有export java home到环境变量中，这里拿到的肯定是undefined，就会抛出异常。我发现我的mac电脑还真没有export JAVA_HOME，于是我加上了这个变量，重新运行appium，完美运行。为什么升级了一下appium就会出现问题了呢？显然是appium的这些依赖库代码更新了。我在appium的package.json中发现了这么一句依赖：1&quot;appium-uiautomator2-driver&quot;: &quot;0.x&quot;,本机问题解决了，Jenkins机器上报的错是一模一样的，肯定是同样的问题。我仔细检查了Jenkins机器上环境变量的配置，突然发现，环境变量配置文件里只是配置了java home，并没有export！于是我在.bashrc中加了export操作，然后重启了机器，运行了一次Job……失败！求助了一波同事，发现其实我这种start appium的方式，服务运行的环境不一样，所以需要在appium.conf里加一句话：1234567script . /data/config/config.properties # 加的就是这一句 export JAVA_HOME=$JAVA_HOME cd /data/log/appium exec appium -a 127.0.0.1 --session-override &gt; appium.logend script果然成功了！总结其实这些问题都不是什么大问题，但是在出现问题之后，我通过各种手段解决了它。最后Job开开心心的跑了起来，我重新配置上了定时任务，让它在迁移机器之后更好的发挥作用，做出更多的贡献！]]></content>
      <categories>
        <category>testing</category>
      </categories>
      <tags>
        <tag>appium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五步让Hexo博客支持PWA]]></title>
    <url>%2F2017%2F09%2F03%2FHexo-PWA%2F</url>
    <content type="text"><![CDATA[某天，突发奇想看了看PWA，觉得很有意思。正好自己有个小博客，遂实验：Hexo博客极速支持PWA。本文不讲PWA的技术原理，只给出让Hexo博客支持PWA的最快方法。第一步支持PWA的第一步，便是全站HTTPS。由于我的博客采用Hexo+Gitpage搭建，完全静态，没有任何后端服务，那怎么支持全站HTTPS呢？Gitpage本身是不能用自定义域名HTTPS的。于是我另辟蹊径，发现了Clowdflare服务。这个服务可以让我的静态博客也支持HTTPS，只要更换DNS就可以，而且免费套餐就足够我用，这对于贫穷的我来说简直再好不过了。具体过程这里就不赘述了，可以参考这篇文章或者自行Google。全站HTTPS完成后，打开你的博客，会看到一个小绿锁，那就没啥问题了。如果你想检测安全性，可以使用SSL Labs进行分析，生成报告。第二步你需要cd到你的博客工程目录下，敲一行命令：1npm install hexo-offline --save（其实这个工具是用来直接生成ServiceWorker代码的，Vue.js官网就使用了这个插件，感兴趣的小伙伴可以直接看它的仓库）然后在站点_config.yml中配置如下内容：123456789101112131415# Offline## Config passed to sw-precache## https://github.com/JLHwung/hexo-offlineoffline: maximumFileSizeToCacheInBytes: 10485760 staticFileGlobs: - public/**/*.&#123;js,html,css,png,jpg,jpeg,gif,svg,json,xml&#125; stripPrefix: public verbose: true runtimeCaching: # CDNs - should be cacheFirst, since they should be used specific versions so should not change - urlPattern: /* handler: cacheFirst options: origin: cdnjs.cloudflare.com这是我的配置，仅供参考。第三步PWA需要有一个manifest.json文件，你需要将创建这个文件到source目录下。如何快速生成manifest文件呢？推荐一款工具：App Manifest Generator，直接生成无烦恼。相关的icon图片放在博客的source/images/icons目录下就可以。没有这个目录就创建一个，记得要和manifest.json中的icon路径匹配。第四步Manifest.json文件需要在head标签里引用，我使用的是next主题，所以我在layout/_partials/head.swing文件中添加一句代码：1&lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt;如果不是next主题，你可以直接打开你的博客，然后用过chrome的开发者工具找到head标签，再从你的代码里找相关的代码，只要找到这么一个文件就可以了。第五步部署你的博客！检测当你完成上面五步操作之后，你的Hexo博客就已经支持PWA啦！如果你想生成一份你的博客对于PWA的相关检测报表，可以安装一个chrome插件：Lighthouse。打开你的博客，直接运行它，稍等片刻，就会生成一份报告。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>pwa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java里Hashmap序列化的一个坑]]></title>
    <url>%2F2017%2F05%2F15%2FJava-Hashmap-Serializable%2F</url>
    <content type="text"><![CDATA[发现问题在做业务需求的过程中，遇到一个非常奇怪的问题。在一个继承了Serializable接口的java bean里按照常规操作添加了一个hashmap和与之对应的getter、setter，就像这样：1234567891011...private HashMap&lt;String, String&gt; mChooseMap;public HashMap&lt;String, String&gt; getChooseMap() &#123; return mChooseMap; &#125; public void setChooseMap(HashMap&lt;String, String&gt; chooseMap) &#123; mChooseMap = chooseMap; &#125;...然后我在某种情况下对含有这个hashmap的java bean进行了deep clone操作，就像这样：123456789101112131415/** * 深度拷贝 要求data对象及其引用对象都实现了Serializable接口才可以用 * * @param o 要深拷贝的对象 */ public static &lt;T&gt; T deepClone(T o) throws IOException, ClassNotFoundException &#123; //将对象写到流里 ByteArrayOutputStream bo = new ByteArrayOutputStream(); ObjectOutputStream oo = new ObjectOutputStream(bo); oo.writeObject(o); //从流里读出来 ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray()); ObjectInputStream oi = new ObjectInputStream(bi); return (T) oi.readObject(); &#125;很简单，对吧？在我的意料之中，这件事简直可以小的忽略不计，完全就是一个非常常规的操作。但是我被打脸了，啪啪的打，因为我发现了一个以前没遇到过的问题……为毛我的数据不见了？本来这个bean里的数据应该依照列表的形式在listview里加载出来，但是我发现我的listview一片空白。最关键的问题是，控制台并没有报错信息啊！查错面对这个问题，我先怀疑了一会儿人生。错误还是要查的，于是我只能先猜猜为什么会出现这个问题。我和之前的代码版本做了对比，发现我只多写了一个hashmap，就出现了问题，于是我怀疑是这个hashmap出现了一个我以前不太了解的坑，导致了现在的问题。Debug首先我要庆幸的是，我的listview是应该拿到后端接口数据之后渲染的，既然控制台没有相关的日志输出，我就debug了一下，看看是不是后端的数据问题。结果我发现了一个让我惊讶的现象，在我处理请求返回的代码中，我正好做了deep clone操作，结果出现了如下错误：咦，控制台毛错没报，为毛一debug就出现了这个问题？在一开始的代码里，我在方法注释里已经写了，深度拷贝 要求data对象及其引用对象都实现了Serializable接口才可以用。这个错太打脸了，我竟然传了一个没有实现序列化接口的对象？再根据刚才的推断，难道说hashmap没有实现序列化接口？追根溯源非常震惊的我赶紧点开hashmap看了一眼：1public class HashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Cloneable, Serializable我的脸有点疼。代码清清楚楚的写着，明明是序列化了……我不甘心，再次debug发现crash出现在这里：123...oo.writeObject(o);...有意思，这不是就是写对象吗，没想明白为什么挂在这里，于是我瞅了一眼hashmap的writeObject方法：12345678910111213private void writeObject(ObjectOutputStream stream) throws IOException &#123; // Emulate loadFactor field for other implementations to read ObjectOutputStream.PutField fields = stream.putFields(); fields.put("loadFactor", DEFAULT_LOAD_FACTOR); stream.writeFields(); stream.writeInt(table.length); // Capacity stream.writeInt(size); for (Entry&lt;K, V&gt; e : entrySet()) &#123; stream.writeObject(e.getKey()); stream.writeObject(e.getValue()); &#125; &#125;是private的？为什么不是public？于是我从crash出现的地方一层层点进去看代码，边看边想是哪里出了问题。看着看着我发现这么一段代码，在ObjectOutputStream类的writeObjectInternal方法中：1234567891011121314151617181920212223...if (clDesc.hasMethodWriteReplace())&#123; Method methodWriteReplace = clDesc.getMethodWriteReplace(); Object replObj; try &#123; replObj = methodWriteReplace.invoke(object, (Object[]) null); &#125; catch (IllegalAccessException iae) &#123; replObj = object; &#125; catch (InvocationTargetException ite) &#123; // WARNING - Not sure this is the right thing to do // if we can't run the method Throwable target = ite.getTargetException(); if (target instanceof ObjectStreamException) &#123; throw (ObjectStreamException) target; &#125; else if (target instanceof Error) &#123; throw (Error) target; &#125; else &#123; throw (RuntimeException) target; &#125; &#125; ... &#125; &#125;这下我看懂了，这不就是说，如果要这对象有自己的writeObject方法，就在这里会用反射的方式执行对象自己的writeObject方法么，这么一来hashmap里的private void writeObject就可以理解了。那我这个问题也就简单了，我在这里加个断点，我看看hashmap到底writeObject除了什么问题不就可以了么。于是再次debug。不看不知道，一看吓一跳！我发现原来问题出现在这里：What?!原来错误是从这里报出来的。我仔细看了一下报错后面的信息，居然是一个其他的类，确实不是一个可以序列化的类。此时此刻我的脸真的很疼。代码不会骗人，我确实传进来了一个没有序列化的类。于是我赶紧点进去报错提示的类里查看，我发现了我是在这个类里往bean中set我的map。我保证这是我第一次这么set：123456contactItem.setChooseMap(new LinkedHashMap() &#123; &#123; put("男", "1"); put("女", "2"); &#125; &#125;);明明是new了一个hashmap，但是writeObject的时候传进去的却是当前的这个类。看来确实是我姿势不对。在我疑惑的时候，我搜到这么一篇文章：hashmap-not-serializable和我差不多的问题嘛，我瞅了一眼回答。The exception message tells you exactly what the problem is: you are trying to serialize an instance of class SimpleSerializationTest, and that class is not serializable.Why? Well, you have created an anonymous inner class of SimpleSerializationTest, one that extends HashMap, and you are trying to serialize an instance of that class. Inner classes always have references to the relevant instance of their outer class, and by default, serialization will try to traverse those.嗯？这话大概意思就是，在一个类里创建一个匿名内部类，相当于扩展了hashmap和要序列化的类的实例。内部类会持有外部类的引用，默认情况下会遍历这些进行序列化。卧槽！原来是这个原因！怪不得我用来new hashmap的这个类被writeObject然后报错了！因为它根本就不能被序列化嘛。解决问题最后我改成了这样：1234LinkedHashMap&lt;String, String&gt; genderMap = new LinkedHashMap&lt;&gt;(); genderMap.put("男", "1"); genderMap.put("女", "2"); contactItem.setChooseMap(genderMap);问题完美解决。以后再也不会犯这个错误了，脸疼，这回深刻的记住了。]]></content>
      <categories>
        <category>踩坑总结</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native App CI]]></title>
    <url>%2F2016%2F12%2F11%2FReact-Native-App-CI%2F</url>
    <content type="text"><![CDATA[应一些小伙伴之邀，总结一篇关于react-native app CI配置的文章，分享出来抛砖引玉~撰写本文时笔者的一些环境版本：macOS：10.12.1npm：3.10.8node：6.9.1背景我们在开发react-native app的过程中，需要用一些手段来保证我们的代码质量、测试与打包，这里简单列举几个例子：代码lint检查静态检查单元测试Android打包apkiOS打包ipa测试报告生成…（等等其他很多设施）这些我列举了一些大家开发过程中比较常用的一些操作。当然，如果我们本机操作的话我相信一般情况不会有人有什么障碍，但是，开发过程中我们需要节约人工时间，提高开发效率，那么我们就需要使用CI系统来帮助我们自动完成这些工作。CI选型众所周知，目前比较主流的CI系统有：Travis，Jenkins，Circle等。其中，Travis，Circle比较适合开源项目和小团队，大公司 or 大团队一般都会选用Jenkins。本篇文章以开源项目reading为例，给大家一步步解析reading的CI配置。由于reading是一个开源项目，所以这里我选择老牌Travis CI作为reading的CI系统，无缝对接Github。Eslintreading项目中使用了eslint作为js的lint检查工具，我们在配置这个工具的时候，只要本地配置完成，那么CI只需要一行代码就可以跑我们的lint脚本。本地是如何配置的呢？我们看看package.json文件中关于eslint的几个依赖：12345678910&quot;devDependencies&quot;: &#123; ... &quot;babel-eslint&quot;: &quot;^7.1.1&quot;, &quot;eslint&quot;: &quot;^3.12.0&quot;, &quot;eslint-config-airbnb&quot;: &quot;^13.0.0&quot;, &quot;eslint-plugin-import&quot;: &quot;^2.2.0&quot;, &quot;eslint-plugin-jsx-a11y&quot;: &quot;^2.2.3&quot;, &quot;eslint-plugin-react&quot;: &quot;^6.8.0&quot;, ... &#125;我们可以看出，reading采用了airbnb的eslint方案eslint-config-airbnb为蓝本，然后根据作者自己的一些习惯进行了小范围的更改，看看项目根目录下的.eslintrc文件：123456789101112131415161718192021222324252627&#123; &quot;extends&quot;: &quot;airbnb&quot;, &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;node&quot;: true, &quot;mocha&quot;: true &#125;, &quot;ecmaFeatures&quot;: &#123; &quot;forOf&quot;: true, &quot;jsx&quot;: true, &quot;es6&quot;: true &#125;, &quot;rules&quot;: &#123; &quot;comma-dangle&quot;: 0, &quot;react/prop-types&quot;: 0, &quot;no-use-before-define&quot;: 0, &quot;radix&quot;: 0, &quot;no-param-reassign&quot;: 0, &quot;react/jsx-filename-extension&quot;: 0, &quot;no-mixed-operators&quot;: 0, &quot;import/prefer-default-export&quot;: 0, &quot;import/no-extraneous-dependencies&quot;: 0, &quot;no-plusplus&quot;: 0, &quot;react/prefer-stateless-function&quot;: 0, &quot;class-methods-use-this&quot;: 0 &#125;&#125;那么eslint配置好了之后，怎么去进行lint检查呢？，我们需要在package.json文件中添加一句脚本：12345&quot;scripts&quot;: &#123; ... &quot;lint&quot;: &quot;eslint&quot;, ... &#125;,最后，我们只需要在项目目录下执行：npm run lint path/to/js文件或目录就可以啦。那么，这句命令也是我们要在CI配置文件中添加的，这个稍后会告诉大家如何写。Test关于测试部分，我之前写过一篇文章React-Native-APP-With-Testing，使用的方案是Mocha+Chai+Enzyme，当时对Jest方案并不是很了解，那时候Jest对React-Native的支持也不是很好，也没有相关的文档可以查阅。但是在最近我发现，Jest对React-Native的支持越来越完善，文档也有了，官方也提供了init命令的Jest相关支持，加上之前的方案中采用了各种开源项目结合，遇到过一两次坑，所以我彻底切换成了Jest来做reading项目的测试。首先我们还是要看看package.json中和Jest相关的依赖：1234567891011&quot;jest&quot;: &#123; &quot;preset&quot;: &quot;react-native&quot; &#125;, &quot;devDependencies&quot;: &#123; ... &quot;babel-jest&quot;: &quot;^17.0.2&quot;, &quot;babel-preset-react-native&quot;: &quot;^1.9.0&quot;, &quot;jest&quot;: &quot;^17.0.3&quot;, &quot;react-test-renderer&quot;: &quot;^15.4.1&quot;, ... &#125;相比之前的组合方案，用Jes之后发现测试部分少了将近一半的依赖，而且切换到Jest，相关的API几乎没有什么大的变化，稍微改一两个地方就可以完全兼容，这让我感到非常开心，所以我几乎没花什么代价就讲测试方案切换为Jest。Jest默认会执行__tests__或__spec__目录下的测试代码，都不需要像Mocha一样写配置文件，同时Jest官网还支持很多其他的配置比如生成测试报表等，非常方便。配置好依赖之后，我们还需要配置package.json中的Jest执行脚本：12345&quot;scripts&quot;: &#123; ... &quot;test&quot;: &quot;jest&quot;, ... &#125;,非常简单的配置，然后我们只需要在项目目录下执行npm test命令即可。CI配置在我们做好上面的那些准备之后，我们就要配置Travis的CI脚本文件了。我们再明确一下我们需要达到的目的：lint检查（eslint）测试（jest）打包（Android &amp; iOS）那么我们至少需要Linux环境和osx环境，然后在不同的OS下都要跑eslint和jest。经过reading一段时间的使用，我发现这样的CI效率并不高，每次打出包的时间都比较长，而且假设一不小心lint出了问题，包也打不出来，但是有可能这时候代码是没问题的。于是我做了优化：一个Linux的环境，专门打Android包一个osx环境，专门build iOS再一个osx环境，专门进行js相关的lint和test这里我做一点说明：Travis目前只有Linux环境支持Android，osx环境支持iOS，但是我本机又是mac，所以js相关的东西我还是用osx环境，这样和本机吻合度高。经过这样的优化，三个并行环境跑ci脚本，单个环境时间上快了很多，总体时间也减少了，效率也提高了。讲到这里，我觉得是时候上一波脚本代码了，代码在项目根目录的.travis.yml中：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 多os相关配置（包含三个os以及env标识）matrix: include: - os: osx language: objective-c sudo: false osx_image: xcode7.3 env: TEST_TYPE=ios - os: linux language: android sudo: required jdk: oraclejdk8 env: TEST_TYPE=android android: components: - build-tools-23.0.1 - android-23 - extra-android-m2repository - extra-android-support - os: osx language: node_js sudo: false node_js: 6 env: TEST_TYPE=jsenv: ...# code climate配置addons: code_climate: repo_token: $CODE_CLIMATE_TOKENbefore_cache:...cache:...before_install:...- rvm get head- if [[ $TEST_TYPE == &apos;android&apos; ]]; then gem install fir-cli ; fiinstall:- curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.0/install.sh | bash- source ~/.bashrc- nvm install 5...- travis_wait npm installbranches: only: - masterscript:- if [[ $TEST_TYPE == &apos;js&apos; ]]; then npm run lint app ; fi- if [[ $TEST_TYPE == &apos;js&apos; ]]; then npm test ; fi# TODO: We use xcodebuild because xctool would stall when collecting info about# the tests before running them. Switch back when this issue with xctool has# been resolved.- if [[ $TEST_TYPE == &apos;ios&apos; ]]; then xcodebuild -project ios/$PROJECT_MOBILE.xcodeproj -scheme $PROJECT_MOBILE -sdk iphonesimulator9.3 -configuration Debug CODE_SIGN_IDENTITY=&quot;&quot; CODE_SIGNING_REQUIRED=NO clean build ; fi- if [ $TEST_TYPE == &apos;android&apos; ] &amp;&amp; [ $TRAVIS_PULL_REQUEST == &apos;false&apos; ]; then cd android &amp;&amp; ./gradlew clean &amp;&amp; ./gradlew resguard --stacktrace ; fi...after_success:- if [ $TEST_TYPE == &apos;android&apos; ] &amp;&amp; [ $TRAVIS_PULL_REQUEST == &apos;false&apos; ]; then fir p path/to/*.apk -T $FIR_TOKEN -c &quot;$TRAVIS_TAG&quot; ; fi这里展示的脚本代码做了一点删减，大家如果想看完整的代码可以看这里。这个脚本里最难的地方其实就是一开始的matrix相关配置，我摸索了几天才搞定。那么之后的配置就大多按照TEST_TYPE进行脚本区分了。这段代码大家其实看字面意思都是可以看懂的，如果一下子看不懂可以看看travis build的生命周期之后再看这段代码就一目了然了，其他的命令就是把本地的一些命令挪到了CI中执行，安装好了相关的预备环境。最后的效果很棒，build jobs的展示也一目了然，大家可以去reading的travis页面看一看效果。最后我们一步步配置好了适用于react-native app的travis ci，其实circle和Jenkins都可以参考，原理是一样的，只是脚本有些许差别。对于现在的我来说，只要我push代码到master，过几分钟我就可以看看结果，然后reading的β包就会出现。我在reading的README中给出的Android β包链接其实就是master分支最新代码打出来的包，ci带来的方便我也切身体会到了。抛砖引玉之文，谢谢大家，有疑问可以讨论起来。]]></content>
      <categories>
        <category>hybrid</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[客户端自动化测试小探索]]></title>
    <url>%2F2016%2F10%2F31%2F%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[本文背景：最近花了两三天时间小探索了一下客户端的自动化测试，起因是因为公司项目在提测之前必须自己手点一些固有的测试case，确定没问题才能提测。实在懒得点，就想探寻一下有没有比较简单的办法解决这个问题。技术选型客户端测试我了解的不是很专业，在我的之前的认知里，主要由appium，macaca等构成，都是通过脚本去控制UI的各种操作，抓取元素模拟点击等等。适用场景上，确实比较适合做一些固有case的回归，但是脚本维护的成本略高，不过支持的语言够多，尤其是appium，几乎支持了所有主流语言，我试着写了一下，问题不大，就是当固有case发生变化的时候比较惨，代码很多都没法用了。虽然理论上讲固有case是不会发生变化的，但是在业务导向的团队中，不可能百分百保证固有case不发生变化，尤其还是在一个新业务的探索发展阶段。我是一个Android DEVER，那么我想了一个够简单的方法：通过AS2.2版本的新特性：Espresso的单元测试录制，让写UT更轻松。但是在我试过之后发现一个鸡肋的问题：录制好的脚本不更改几乎没法用。因为在大型的app上，元素的定位不是那么简单的，而录制的脚本中几乎都用allOf来定位元素，显然就是不行的，那么维护脚本的成本就大了，很多情况下不亚于直接用appium直接去写，所以这个方案我就放弃掉了。我理想中的方案是：维护脚本成本够低、写test case够简单、可读性够强、如果能Android &amp; iOS共用那更棒，最关键的一点：时间成本要少。于是我邂逅了Calabash。Calabash上手我第一眼就相中它的原因就是：它可以用一种类似自然语言的方式编写测试用例。以往的方式都是TDD，而calabash是BDD，这让我感到很新奇，于是我做了一波尝试。先给大家看看我写的第一个固有case（是固有case里最简单的一个）：123456789101112131415161718192021222324252627282930Feature: xxx固有用例 Scenario: 功能：首页 Then I see &quot;跳过&quot; When I press &quot;跳过&quot; Then I press &quot;上海&quot; When I press view with id &quot;city&quot; Then I see &quot;海外&quot; When I press &quot;海外&quot; And I press view with id &quot;start_search&quot; When I enter &quot;东京&quot; into input field number 1 Then I press list item number 1 Then I see &quot;东京&quot; When I press &quot;美食&quot; Then I see &quot;美食&quot; Then I go back When I see &quot;景点&quot; Then I press &quot;景点&quot; Then I see &quot;景点&quot; Then I go back Then I press view with id &quot;title_image&quot; Then I wait for 5 seconds Then I press webview text &quot;特价机票&quot; Then I wait for 5 seconds Then I go back Then I go back When I scroll down recyclerview with id &quot;main_listview&quot; count 5 Then I see &quot;猜你喜欢&quot; Then I press view with id &quot;root_rl&quot; number 1 Then I wait for 10 seconds这个没写过代码的人我相信都看得懂，其实就是用我们常规的思维模式去写测试用例。用法非常简单，如果是Mac的小伙伴那简直不要太爽，天生自带ruby，直接用gem去安装calabash就可以，这里推荐安装calabash-android，其实安装calabash-ios应该是类似的，大家去calabash的github organization中找相应平台的repo就可以，这里我以Android为例。安装完之后，直接用calabash gen生成目录就可以，固有的目录都会自动生成，其实主要和我们相关的就是features目录。这里面分为三部分：step宏定义+自定义各种hooks的support支持自己写的测试用例，文件名用.feature结尾很简单，上面的测试case就是自己写的测试用例。到这里我突然要告诉大家：calabash只支持ruby。其实如果我不说，估计大家都考虑不到语言，因为从这个case上看，根本看不出语言。不过大家别担心，这里用到ruby的地方无非在一些自定义step和hooks，其他的目前我没发现哪里还需要用了，而且用到的ruby极其基础简单，不需要学，不知道的Google一下就完事了。最后用calabash run命令启动就可以，别忘了要有apk或者ipa包，这部分我就不细说了，去github看会比较详细。其实到这里就讲完了，接下来我会分享一下我这两天遇到的坑，也是我觉得用calabash的难点。疑难杂症难点一：定位元素这部分以Android为例，显然很多页面经常会出现id相同的情况，那么我们要通过各种手段定位到唯一的元素。Android极其推荐使用sdk tools目录下的uiautomatorviewer进行元素抓取和定位，配合肉眼和calabash console进行定位，三者结合基本上差不多，无非就是花时间多少的问题。那么webview部分calabash也是支持的，主要是通过css以及各种条件筛选进行定位，其中text内容匹配用到的最多。这部分只能慢慢摸索，有经验就会快了。在定位元素的过程中，会遇到一些宏定义的step不够用的情况，需要自己自定义step。这里给大家看我这两天自定义的几个step：12345678910111213Then /^I press webview text &quot;([^\&quot;]*)&quot;$/ do |text| touch(&quot;android.webkit.WebView css:&apos;a&apos; &#123;textContent CONTAINS[c] &apos;#&#123;text&#125;&apos;&#125;&quot;)endThen /^I press view with id &quot;([^\&quot;]*)&quot; number (\d+)$/ do |id, number| tap_when_element_exists(&quot;* id:&apos;#&#123;id&#125;&apos; index:#&#123;number&#125;&quot;)endWhen /^I scroll down recyclerview with id &quot;([^\&quot;]*)&quot; count (\d+)$/ do |id, count| for i in 0..Integer(count) scroll(&quot;android.support.v7.widget.RecyclerView id:&apos;#&#123;id&#125;&apos;&quot;, :down) endend这ruby很简单把，无非就是包了一层calabash的api然后识别了一下，没啥技术含量，主要就是自己方便用，扩展一下step，这三个自定义的step我在上面的case中都有用到。难点二：流程控制Feature我们在上面的case中可以看到有Feature的标识，这是calabash的一个控制单元（我的理解），每运行一个Feature，apk都会卸载重装，保证每次都是全新无副作用的应用。Scenario这个标识是囊括在Feature中的，一个Feature可以有很多个Scenario，运行每个Scenario的时候应用只会退出再重进，不会卸载再重装。Hooks在feature/support包下，我们会看到这么几个ruby文件：app_installation_hooks.rbapp_life_cycle_hooks.rbenv.rbhooks.rb可以看到，基本上都是hook用的，我们看一个简单的app_life_cycle_hooks.rb理解理解：12345678910111213require &apos;calabash-android/management/adb&apos;require &apos;calabash-android/operations&apos;Before do |scenario| start_test_server_in_backgroundendAfter do |scenario| if scenario.failed? screenshot_embed end shutdown_test_serverend这是默认就生成好的，从字面意思上看，就是app生命周期的hook，这里可以看到，在主要用到了Before和After关键字进行操作，这个显然很容易就看懂了，于是我自己写了一个在每个step执行之后都等待2秒的hook，下面的代码写在hooks.rb中（这个文件默认生成是空的）：12345require &apos;calabash-android/calabash_steps&apos;AfterStep do |scenario| sleep 2end很容易对吧？关于这部分想多了解的可以看cucumber wiki中的Hooks部分。总结首先，calabash是我最后唯一选中的客户端自动化固有case的方案。这里说下原因：脚本维护成本很低，就算固有case发生变化，也可以花很少的时间迅速更改脚本我们的业务固有case数量不大，操作主要涵盖的部分calabash都可以完成，编写脚本的成本低，无语言障碍可读性非常强，代码简单易懂，任何一位DEVER都可以零成本上手，有Mac的连装环境都差不多省了小范围组内使用成本低，坑有但是并不大，都可以解决，某些机型不兼容问题直接用genymotion跑就行了，最简单（主要还是固有case不复杂）Android &amp; iOS都可以使用玩起来很有意思，对于我这种懒人来说是福音估计还有一些高级的玩法我还不会，不过目前这些都够我写一些固有case了，目前我们组内将会对这个方案进行评估，没啥问题就组内小范围用了，如果有感兴趣的朋友欢迎一起讨论唷。谢谢大家。]]></content>
      <categories>
        <category>testing</category>
      </categories>
      <tags>
        <tag>calabash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Code Review]]></title>
    <url>%2F2016%2F09%2F30%2FTalk-About-Codereview%2F</url>
    <content type="text"><![CDATA[最近思考一个问题，如何进行高效的codereview，有没有好的工具可以使用，于是花了两三天时间在Google里淘了一番，这里留下记录。Phabricator首屈一指的codereview工具，当然并不限于codereview，这个工具我体验了下，功能很强大。除了codereview之外，还有task，bug的管理，wiki管理，项目管理等功能，而且还有自定义的功能，界面也很清爽。个人觉得几乎没什么可以挑剔的地方，如果正好需要一套工具互相配合的团队，选这个就没错了。（如果是我，我就比较倾向于这个工具的）体验PhabricatorReviewNinja刚开始体验这个工具，纯粹是因为好奇，被这名字吸引住了：英文+日文的读音，再加上我又是火影迷……体验之后感觉还真的不错。这个工具非常轻量级，而且只支持github，很适合个人、小团队使用。专注于codereview这个功能，界面什么的也很清爽，可以通过一些特殊的comment符号让github的merge按钮产生响应的变化，同时还会改变github pr的checks。如果我的场景只有github，那我会选择用这个工具，接入也非常简单，开源免费。ReviewNinja的review效果Codacy这个工具有点像Phabricator，不过这个工具有代码质量的统计和建议，还有分析，codereview功能也很全，还有dashboard可以一览项目的各种指标，非常赞，关键是这个工具可以对接github、bitbucket、jira和Jenkins，还可以对接hipchat和slack等，功能很强大，值得好好挖掘一下。个人觉得这个工具适用范围挺广的，一些对项目质量有追求的不仅仅限于codereview的可以尝试用一用，对github上的public仓库是免费的。Codacy FeaturesCodacy体验效果RhodeCode支持git，svn，多仓库管理，界面体验也比较清爽，功能和codacy有不少重合的地方。RhodeCode FeaturesRhodeCode demoGerrit这是Google开源的codereview工具，和Phabricator并驾齐驱，也很强大，只不过我个人不太喜欢这个界面风格……这个我没有自己去搭过，只是看了官网的一些信息，功能上不输Phabricator。喜欢的朋友可以去体验一把。总结以上列举了我这两三天着重看的一些codereview工具，适用场景也大概总结了一下。高效的codereview非常重要，如果有好的工具帮助我们进行codereview，往往会达到事半功倍的效果。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>code review tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈React-Native With Redux]]></title>
    <url>%2F2016%2F09%2F07%2FReact-Native-With-Redux-Refactor%2F</url>
    <content type="text"><![CDATA[有一段时间没写react-native redux相关文章了，使用中多多少少有些感悟，总结了一些，这次把它写出来。本文目录redux三大原则重新认识redux三要素react-redux的最新用法redux性能优化redux周边设施总结 &amp; 其他撰写本文时笔者的相关环境如下：操作系统：OS X 10.11.6react-native版本：0.32.0npm版本：3.9.5node版本：4.4.5redux三大原则首先，我们明确一点：redux的核心思想就是FLux架构，单向数据流。单一数据源在redux中，所有的state最后都会被combine起来，变为一个大的state树，这个state树只存在于唯一的一个store中。这么做的好处是开发和调试都变得很方便，也很好理解。state只读改变state唯一的办法就是通过触发action，别无他法。这么做非常纯粹，确保没其他副作用，state不会被任意修改。纯函数修改state想要修改state，在action被触发之后，需要编写reducer来进行修改，reducer只是一些纯函数，它会接受到action和state，返回全新的state。重新认识redux三要素action执行动作，把数据传递到store，触发它是用来改变state的，它是store的唯一数据来源。reducer纯函数，用来修改/更新state，action只是说明有动作发生了，但是具体产生什么样的作用（state如何变更），还是reducer说了算。在修改完state之后，通过Object.assign，或者…state或者immutable返回全新的statestore整个应用唯一维护state树的地方，是单一的。可以获取、更新state，还可以注册监听。这三个元素像齿轮一样运转起来，形成了FLux架构的单向数据流。react-redux最新用法react-redux这个库，在redux和react结合使用的时候几乎是必用的。在经历过某次升级后，它的Provider组件用法发生了一点变化，最新的用法如下：1234567import &#123; Provider &#125; from 'react-redux';const Root = () =&gt; ( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;);redux性能优化性能优化第一步，就是搞清楚action和reducer的关系。如果搞不清关系，就会像我之前一样，大量页面被过度渲染。它俩是什么关系呢？实际上它俩是多对多的关系。也就是说，一个action操作可能会造成state树中的一个或者某几个部分发生改变，就对应了一个或多个reducer，多个action操作也同理，这是我们必须明确的。如何避免引入redux之后造成页面过度渲染？首先我们要搞清楚，为什么会过度渲染。在一个引用了redux的rn app中，state树是唯一的。但是在某个页面中，控制它的状态只是整棵状态树的子集，也就是state树中的一部分。如果没搞清action和reducer的关系随便乱用，很容易造成一个reducer控制着多个页面的情况（也就是说页面组件和reducer的状态子集形成了多对多的关系），那就妥妥的过度渲染了。举个简单的例子：reducer A控制着页面C和D的状态，当发起了一个action之后，A改变了，那么C和D就会调用render方法进行无用渲染。但是这时候很可能C或D并不是正在展示的页面，这里就出现了过度渲染，如果页面多，就会造成卡顿情况。如何避免过度渲染？action是用来发起修改state操作的，具体怎么改是由reducer决定的，但是最终所有的reducer都会被combine成一个，那么reducer的拆分就是我们需要考虑的点。每一个reducer都控制了状态树的一个子集的变化，我们通过react-redux库的connect函数向组件注入状态，那么我们就需要把reducer拆分到较小的单元，使得一个页面的状态集合是由一个或多个reducer来控制，这里是一对多的关系，能做到这一点，就能避免过度渲染的问题。还是用刚才的例子，拆分后的reducer A只控制页面C，页面D由另一个reducer控制着，那么当A改变了，只会引起C的渲染，就能保证只渲染正在向用户展示的那个页面了。redux周边设施react-redux这个应该是首当其冲的了，在redux官方文档中都有提及，只要用react/react-native，引入redux，就会引入这个库打配合，简单好用。redux-logger这个库的用法很简单，它的作用是一次配置好，以后所有action触发了state的变化，都会用比较鲜艳的log日志打印出来，用chrome调试就可以很明显的看到，这样就能一清二楚每一个action最终都导致了state前后发生了什么样的变化。redux-thunk这个库的作用主要是异步action。在我们引入redux之后，肯定会有很多异步操作，我们想把这些异步操作和组件剥离开，那么最直观的就是放入action中进行处理，通过thunk实现异步action。使用简单，理解起来也方便，很多刚入坑的同学处理异步action一般都会选用这个库。redux-saga这个库本质上也是处理异步action的，但是相对thunk来说，它就没那么直观没那么好理解了。这个库主要思想就是通过es6的generator，把异步promise操作变成了类似async和await的同步写法，但是saga更强大。saga主要运用了协程的思想，在异步操作变为同步写法的时候，提供了非常便利的可测试性，而且简化了action。在引入saga之后，action里的代码就变得非常纯粹了，什么都不干，只触发action，具体的处理，不管是同步还是异步统统挪到saga中，写法也变得非常简洁。相对测试来说，写UT也变得清晰了很多，因为saga天生就是支持步进的，那么action对应的测试就写在saga包中就可以，因为真正处理action逻辑的是saga。相比之下，thunk就不好写测试了，一般用thunk的，测试都是根据reducer来写的，thunk中的操作就变得不可控了。immutable.js这个库是Facebook的，主要是做deep clone，比较高效，和redux结合的地方就是reducer返回全新state的地方。其实还有很多其他周边设施，我这里列举的是目前比较火或者比较主流的一些，当然了我也不一定全部都清楚，如果大家有更好的欢迎留言交流。总结 &amp; 其他对于我这枚菜鸡来说，还有很长的路要走，文中提到的点大多都在我自己的开源项目reading中有体现，也非常欢迎大家关注。最近收到了几个高质量的PR非常开心，在学习的同时把reading做的更好也是我的愿望。只有实战、写代码、踩坑，才能总结、重构、进阶，这条路没有捷径。只要方向没错，那就努力！]]></content>
      <categories>
        <category>hybrid</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊我的处女作：reading]]></title>
    <url>%2F2016%2F07%2F05%2FTalk-About-Reading%2F</url>
    <content type="text"><![CDATA[戳我关注reading不知不觉reading项目已经有500+star了，作为自己的处女作，感到非常开心。感谢关注reading的人，我会坚持继续维护下去。No Profit, No Advertisement, Only Feelingsreading初衷其实做reading项目的初衷很简单，就是我想自己尝试着用react-native写一个app。真正开始写的时候，大概是五、六个月前的样子，想把自己在实战中的一些经验用代码的方式展现出来，抛砖引玉，和大家一起交流进步。那时候github上国内的react-native开源app还很少，而且大多都没继续维护了，于是自己下决心好好做一个，好好维护下去。不知不觉半年了，每次打开reading项目代码，还是感到一阵亲切。开源reading，可以让reading成长的更快更好，同时对我而言也是一样。对待自己的处女作开源项目，我格外认真，目标是把reading打造成一个高质量的开源项目。reading架构演进再小的APP也有自己的架构，reading也不例外。在项目的readme中，我简单的提到了reading的架构，这里我分享下reading从一开始到现在发生了哪些变化。reading是基于react-native开发的Android &amp; iOS双平台的APP，数据流和状态通过redux进行管理，并且在摸索着进行UT。reading现在的架构是这样的：actions：redux中action部分都在这里components：reading中用到的通用控件，全部抽离出来在这里，同时任何一个react-native app，都可以直接拿去用，支持Android &amp; iOS双平台constants：这里主要是一些常量，比如action的type，一些字符常量，url常量，还可以有颜色常量等各种containers：容器层，需要注入state的地方，我会用容器包一层。如果有需要页面中用到多个组件拼成，也通过容器包一层，达到复用。app入口也在这里img：这里主要放图片资源pages：这里主要放页面，其实就是组件。目前来看，这里面的组件其实都是reading的单个页面。其实页面是可以组合的，在外面包一层容器的话，就可以进行组合。一些复杂的页面，完全可以通过这种方式去做，复用性更高，而且还能解耦reducers：redux中reducer部分都在这里，reducer和action不一定是一一对应的，数量也不一定是相等的。state可以进行各种颗粒度的细分，最后通过combine函数合为一个。拆分state非常重要，它涉及到性能优化，不同的state通过不同的reducer进行处理，然后渲染不同的页面，甚至是渲染同一个页面中的不同组件，这样就避免了过渡渲染。如果不拆分，当一个大state改变的时候，所有的页面都会重新render，这是很浪费性能的store：redux的store部分，通过reducer和各种各样的middleware创建store。例如redux-thunk，redux-logger等utils：工具包root.js：统一index.android.js和index.ios.js入口，通过react-redux中的Provider组件包裹整个APP以上均为reading的js部分。目前reading中除了引用的第三方库含有原生代码，我几乎没写什么原生代码，我想尝试用js的方式去写。不排除如果后面功能复杂的话，会加一些原生（暂时并不会写OC……）。reading项目是我主打以rn为主原生为辅的开发方式构建跨平台的开源APP。起初一开始，reading是没有这些东西的，所有代码都是一坨……完全没有模块划分的东西。当时我还在饿了么尝试在蜂鸟众包app中加入react-native模块，也没有任何架构，完全不具备可扩展性。第一次重构发生在我想要加功能的时候，根本没法加，于是我本能的感觉代码是有问题的。当时react-native资料除了官方文档其他的少之又少，中文资料根本没有，于是我找到了一个老外写的app，感觉很6，clone了代码下来读。读完了之后，照猫画虎的重构了一下，有了简单的分层，这就是reading架构的雏形。在这个时候，我才明白redux是个什么东西，怎么用，分层是什么样的。第一次里程碑由于根本没法加功能，于是我进行了第一次重构。我的记忆中，经历过第一次重构，reading的代码从一坨变成了这样：actions：redux中action部分都在这里components：reading中用到的通用控件，并且在当时所有的页面也在这里，并不支持ios平台constants：这里主要是一些常量，当时只有action的typecontainers：容器层，app入口也在这里，当时我所有的页面都会有一个容器，存在资源浪费和过渡渲染的问题img：这里主要放图片资源reducers：redux中reducer部分都在这里，当时我误认为reducer和action必须一一对应，于是我按照一一对应去写的，这样的思路是有问题的store：redux的store部分，通过reducer和各种各样的middleware创建store。当时还不太清楚异步action和同步action的问题，所以redux-thunk都没用上，更别提redux-logger了utils：工具包root.js：统一index.android.js和index.ios.js入口，通过react-redux中的Provider组件包裹整个APP可以看出，这就是reading现有架构的雏形。它已经初步规定了数据流向，规定了系统分层与组件间的关系等。在这个架构的基础上，我添加了reading最初也是最基础的几个功能。再一次改变写着写着，也发了几个版本，感觉性能有点问题，也看了更多的一些代码，跟着官方更新的脚步思考，又看了一些文章，反反复复，我觉得我的代码存在一些问题，需要进一步修改。当时我意识到的问题有：redux使用存在过度渲染问题，数据流管理有点乱，需要重点优化组件和页面的概念有点模糊，需要进一步界定action和reducer的概念有点模糊，需要更清晰的理解组件化思想愈发明确，action中需要异步与同步共同处理首先，关于redux的问题，其实是一连串的问题，也是我之前没有搞清楚的概念。我一直认为action和reducer是一一对应的，其实完全不是的，更形象的说，是多对多的。redux的state最后会合并成一个，所以为了避免每次改变state都刷新所有的页面，应该拆分state，局部刷新，这样可以避免过度渲染。只要我们根据实际情况，把reducer拆开，action可以根据一个页面定义一个，然后一个页面完全可以对应多个reducer去操作，这样不光解决了性能问题，数据流管理也更加清晰了。其实这里涉及到2个框架：redux和react-redux，拆分了之后需要用react-redux的connect函数按需注入dispatch和state，这时候拆分的reducer就起作用啦，模块中containers部分也得到了优化，从一个页面对应一个容器，优化到需要注入的页面才有容器，不需要的就不要容器。概念区分清楚了，定义就完全自由了。其次，关于组件和页面的问题，我干脆加了一个pages包，专门放页面，相当于页面级的组件，和业务相关，components里只放通用模块组件，保证我拿到别的项目分分钟一样可以用起来，这样一拆分，瞬间清爽多了。组件化思想驱使我在action中处理同步+异步的问题，之前的代码中，网络请求等明显的异步action是放在页面组件中的，现在全部抽走拿到action中，也就是说V这一层被解耦了，只和action、reducer相关，这个action我感觉有点像Android MVP架构中的P层。Android &amp; iOS统一架构暂时稳定了一段时间，我考虑兼容iOS。因为我起初是只做了android平台，所以在兼容ios的时候，主要还是在UI的部分，其实并不难，在做android的时候，我就考虑到了后续兼容ios的问题，组件方法函数等都考虑到了ios，这部分我做的最多的还是UI层的统一。在代码改动最少的情况下兼容ios，而且reading的业务逻辑并不复杂，于是很容易就做到啦。reading发展到现在，大致上经历了这四个过程，后面还有很长的路要走，要学习的东西还有很多。reading未来发展下一步，reading会基于Android &amp; iOS双平台的基础上，继续做一些事情，在这里我简单列举一下：redux还有很多更高级的玩法，还需要再琢磨琢磨redux的官方文档和react-redux的API文档，翻译的很棒的中文版在这里逻辑+UI的测试框架我已经跑通，如何编写有价值的测试用例也是我需要学习的目前reading项目中Navigator机制用的是官方提供的Navigator实现双平台的统一，但是关注react-native动态的小伙伴都知道，官方正在做一款新的Navigator机制：NavigationExperimental。最近的版本release note里关于这个的内容很多，暂时还不稳定，所以我还没去看，官方在issue里表示过，新的Navigator很快就会release，到时候我会在reading中进行切换我会时刻关注react-native动态，会在reading的代码中体现出来最后说几句reading还有很长的路要走，我的目标是把它打造成国内优质的react-native APP开源项目，让想学习rn快速搭建APP的人通过学习reading的代码，系统性的搭建起属于自己的APP，并且进行各种各样的架构优化与演进，用于开源项目或者商业项目，体现价值。欢迎大家与我交流，提issue，pr给我。特别感谢感谢鬼道大哥star了reading项目，鼓励我让我继续加油。刚开始接触react-native的时候，什么都不会，很多问题都是请教了鬼道大哥才明白，经常交流，受益匪浅。同时，热烈庆祝weex开源，阿里巴巴对技术的执着追求让我敬仰，对开源社区的贡献让我钦佩。虽然我现在还非常弱小，但我也非常愿意在开源社区贡献自己的力量，伴随我的成长，相信这股力量会越来越强大。]]></content>
      <categories>
        <category>open source</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit2源码分析（一）]]></title>
    <url>%2F2016%2F05%2F29%2FRetrofit2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文将顺着构建请求对象→构建请求接口→发起同步/异步请求的流程，分析retrofit2是如何实现的。组成部分Retrofit2源码主要分为以下几个部分：retrofitretrofit-adaptersretrofit-converters本篇先分析retrofit部分，也就是retrofit源码的主干部分。下面顺着retrofit2的使用流程进行分析。Retrofit对象的构建首先我们看看构建一个Retrofit对象，都需要或者可选哪些配置：1234567891011121314151617181920212223242526272829303132333435/** * Build a new &#123;@link Retrofit&#125;. * &lt;p&gt; * Calling &#123;@link #baseUrl&#125; is required before calling &#123;@link #build()&#125;. All other methods * are optional. */ public static final class Builder &#123; //支持的平台 private Platform platform; //发起请求的okhttp3的client工厂 private okhttp3.Call.Factory callFactory; //okhttp3里的HttpUrl对象，用来解析和包装url private HttpUrl baseUrl; //转换器的工厂集合，retrofit构建可以插入多个转换器，比如gson转换器，Jackson转换器等 private List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); //用来发起request和接收response的Call适配器，retrofit支持rxjava就是通过引入retrofit-adapters支持的，就是这个CallAdapter，这里先不作过多解释 private List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(); //Executor并发框架，包括线程池等 private Executor callbackExecutor; //是否需要立即生效 private boolean validateEagerly; Builder(Platform platform) &#123; this.platform = platform; // Add the built-in converter factory first. This prevents overriding its behavior but also // ensures correct behavior when using converters that consume all types. converterFactories.add(new BuiltInConverters()); &#125; public Builder() &#123; this(Platform.get()); &#125; ... &#125;Retrofit对象的构建使用了建造者模式，这里有一系列参数可以供我们选择，我给这些参数加了注释。这里构造方法中Platform.get()就是获取当前使用retrofit的平台信息，之前我用retrofit的时候，以为只支持Android平台，没想到还支持java8和ios，只不过这里的ios是指通过robovm平台构建的ios程序，目前robovm主要的成功案例还是游戏，跨android &amp; ios双平台。在Builder中，有一个比较重要的配置项，就是baseURL。我们设置baseUrl就是一个string字符串，retrofit是这么处理的：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Set the API base URL. * &lt;p&gt; * The specified endpoint values (such as with &#123;@link GET @GET&#125;) are resolved against this * value using &#123;@link HttpUrl#resolve(String)&#125;. The behavior of this matches that of an * &#123;@code &lt;a href=""&gt;&#125; link on a website resolving on the current URL. * &lt;p&gt; * &lt;b&gt;Base URLs should always end in &#123;@code /&#125;.&lt;/b&gt; * &lt;p&gt; * A trailing &#123;@code /&#125; ensures that endpoints values which are relative paths will correctly * append themselves to a base which has path components. * &lt;p&gt; * &lt;b&gt;Correct:&lt;/b&gt;&lt;br&gt; * Base URL: http://example.com/api/&lt;br&gt; * Endpoint: foo/bar/&lt;br&gt; * Result: http://example.com/api/foo/bar/ * &lt;p&gt; * &lt;b&gt;Incorrect:&lt;/b&gt;&lt;br&gt; * Base URL: http://example.com/api&lt;br&gt; * Endpoint: foo/bar/&lt;br&gt; * Result: http://example.com/foo/bar/ * &lt;p&gt; * This method enforces that &#123;@code baseUrl&#125; has a trailing &#123;@code /&#125;. * &lt;p&gt; * &lt;b&gt;Endpoint values which contain a leading &#123;@code /&#125; are absolute.&lt;/b&gt; * &lt;p&gt; * Absolute values retain only the host from &#123;@code baseUrl&#125; and ignore any specified path * components. * &lt;p&gt; * Base URL: http://example.com/api/&lt;br&gt; * Endpoint: /foo/bar/&lt;br&gt; * Result: http://example.com/foo/bar/ * &lt;p&gt; * Base URL: http://example.com/&lt;br&gt; * Endpoint: /foo/bar/&lt;br&gt; * Result: http://example.com/foo/bar/ * &lt;p&gt; * &lt;b&gt;Endpoint values may be a full URL.&lt;/b&gt; * &lt;p&gt; * Values which have a host replace the host of &#123;@code baseUrl&#125; and values also with a scheme * replace the scheme of &#123;@code baseUrl&#125;. * &lt;p&gt; * Base URL: http://example.com/&lt;br&gt; * Endpoint: https://github.com/square/retrofit/&lt;br&gt; * Result: https://github.com/square/retrofit/ * &lt;p&gt; * Base URL: http://example.com&lt;br&gt; * Endpoint: //github.com/square/retrofit/&lt;br&gt; * Result: http://github.com/square/retrofit/ (note the scheme stays 'http') */ public Builder baseUrl(HttpUrl baseUrl) &#123; checkNotNull(baseUrl, "baseUrl == null"); List&lt;String&gt; pathSegments = baseUrl.pathSegments(); if (!"".equals(pathSegments.get(pathSegments.size() - 1))) &#123; throw new IllegalArgumentException("baseUrl must end in /: " + baseUrl); &#125; this.baseUrl = baseUrl; return this; &#125;这里的注释非常详细，讲解了baseUrl到底是什么，应该遵循什么样的格式，然后经过HttpUrl的解析，组合成okhttp3用来请求的url链接。这里规定了baseUrl末尾应该以/符号结尾，在后续API的接口类中后半部分定义应该不以/开头，这是和retrofit 1.x版本不同的地方。最后就是build方法了：12345678910111213141516171819202122232425262728293031/** * Create the &#123;@link Retrofit&#125; instance using the configured values. * &lt;p&gt; * Note: If neither &#123;@link #client&#125; nor &#123;@link #callFactory&#125; is called a default &#123;@link * OkHttpClient&#125; will be created and used. */ public Retrofit build() &#123; if (baseUrl == null) &#123; throw new IllegalStateException("Base URL required."); &#125; okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters. List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories); return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly); &#125;从这里可以看出如果我们不设置callFactory，retrofit会默认帮我们new一个OkHttpClient，如果我们不设置callbackExecutor，也会帮我们默认获取到当前平台默认的callbackExecutor，最后new一个Retrofit对象，到这里，Retrofit对象的构建就讲完了。这里有个值得注意的地方：CallAdapter和Converter的工厂集合都使用了保护性拷贝。那么保护性拷贝是什么呢？这是用来保证代码健壮性的。为什么要在这里用？因为Builder的这些配置的方法都是public的，虽然看起来这些是不可变的，但是可以通过传入构造参数来修改引用的值，这就会造成约束条件被破坏，所以使用了保护性拷贝来防止这种情况。API的编写我们已经new好了一个我们需要的Retrofit对象，那么下一步就是编写API了。如何编写API呢？Retrofit的方式是用过java interface和注解的方式进行定义。例如：1234public interface GitHubService &#123; @GET("users/&#123;user&#125;/repos") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path("user") String user);&#125;这是官方文档上的一个例子。这里简单的定义了一个API，针对这小部分代码，我们来分析分析。首先是GET注解，我们来看看这个注解是什么：1234567891011121314/** Make a GET request. */@Documented@Target(METHOD)@Retention(RUNTIME)public @interface GET &#123; /** * A relative or absolute path, or full URL of the endpoint. This value is optional if the first * parameter of the method is annotated with &#123;@link Url @Url&#125;. * &lt;p&gt; * See &#123;@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL&#125; for details of how * this is resolved against a base URL to create the full endpoint URL. */ String value() default "";&#125;这是一个运行时的方法注解，用来构造get请求，唯一的参数是一个string值，默认是空字符串。那么我们可以理解了，@GET(xxxxx)就是构造了一个用于get请求的url。下一个注解是Path注解，是一个运行时的参数注解，它是为了方便我们构建动态的url，参数是一个string值，还可以设置参数是否已经是URL encode编码，默认是false。最后我们看到，通过Call&lt;T&gt;构建成一个interface。Call&lt;T&gt;这个接口分别在OkHttpCall和ExecutorCallbackCall中做了具体的实现。创建retrofit service最最关键的一步来了。我们new好了retrofit对象，也写好了API interface，那怎么请求这个API呢，我们需要通过retrofit的create函数，创建一个service，然后调用API的接口方法进行请求并获得回传。使用当然很简单：1GitHubService service = retrofit.create(GitHubService.class);是的你没有看错，就这么一句话就搞定了。具体是怎么实现的呢？我们先来看看create的代码：12345678910111213141516171819202122232425@SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety. public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod serviceMethod = loadServiceMethod(method); OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125;这里实现的非常巧妙，使用了java的动态代理。什么是动态代理？就是代理类、委托类都要实现同一个接口，然后代理通过接口代理委托类。由于java的单继承特性，所以动态代理是基于接口的，只能针对接口创建代理类。所以这里create的时候，先判断了一下传进来的service是不是interface，如果不是接口类型或者包含多个接口，就会直接抛异常。然后就是重头戏：动态代理的invoke方法。这个方法是InvocationHandler接口中唯一的方法，这个接口是代理实例实现的接口。代理实例调用方法时，InvocationHandler接口会将对方法的调用指派到代理的invoke方法中，进行处理。这里当method是一个对象的method时，直接调用。如果是平台的默认方法（根据Platform代码中这种情况是java8）就直接执行调用默认方法。正常在android平台下，会把method加载到ServiceMethod对象中，这里用了缓存，如果缓存中有SeriveMethod就直接取出，如果没有接new一个，然后用过ServiceMethod初始化了一个OkHttpCall对象，最后通过callAdapter的adapt方法返回一个代理了Call的实例。这个方法在这两个类中有具体的实现：DefaultCallAdapterFactory和ExecutorCallAdapterFactory。这两个工厂类又在哪里会用到？就在Retrofit对象的build方法中：123// Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));那我们再看看platform.defaultCallAdapterFactory(callbackExecutor)里是什么：123456CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; if (callbackExecutor != null) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; return DefaultCallAdapterFactory.INSTANCE; &#125;可以看到如果在创建Retrofit对象时callbackExecutor为空的话，就new一个ExecutorCallAdapterFactory对象作为CallAdapter，如果不为空就返回DefaultCallAdapterFactory的实例。发起请求这里我们按照retrofit官方文档中的例子构建Retrofit对象。retrofit2中，同步和异步不再用interface的定义区分，统一都为Call&lt;T&gt;，但是在Call接口的方法中有区分，我们来看看：1234567891011121314/** * Synchronously send the request and return its response. * * @throws IOException if a problem occurred talking to the server. * @throws RuntimeException (and subclasses) if an unexpected error occurs creating the request * or decoding the response. */ Response&lt;T&gt; execute() throws IOException; /** * Asynchronously send the request and notify &#123;@code callback&#125; of its response or if an error * occurred talking to the server, creating the request, or processing the response. */ void enqueue(Callback&lt;T&gt; callback);execute()是同步请求，enqueue()是异步请求。我们先看异步请求是如何实现的。enqueue这个方法在以下两个地方有实现：OkHttpCall和ExecutorCallbackCall。那么当发起了异步请求之后，就会调用ExecutorCallbackCall中的enqueue方法，ExecutorCallbackCall中一个对象叫1final Call&lt;T&gt; delegate;这就是代理的Call对象，在这里就是我们在动态代理create方法中用过ServiceMethod对象构造的OkHttpCall对象，那么这里调用的enqueue方法，就是调用了代理的OkHttpCall对象的enqueue方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Override public void enqueue(final Callback&lt;T&gt; callback) &#123; ... //各种判空等代码，这里先省略了 okhttp3.Call call; Throwable failure; if (canceled) &#123; call.cancel(); &#125; call.enqueue(new okhttp3.Callback() &#123; @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) throws IOException &#123; Response&lt;T&gt; response; try &#123; response = parseResponse(rawResponse); &#125; catch (Throwable e) &#123; callFailure(e); return; &#125; callSuccess(response); &#125; @Override public void onFailure(okhttp3.Call call, IOException e) &#123; try &#123; callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; private void callFailure(Throwable e) &#123; try &#123; callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; private void callSuccess(Response&lt;T&gt; response) &#123; try &#123; callback.onResponse(OkHttpCall.this, response); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; &#125;); &#125;可以看到，这里其实是用了okhttp3的请求回调，做了一层封装，变成了retrofit2的Callback，也可以看出retrofit2和okhttp3是深度集成的。到这里，异步请求就一目了然了。我们还可以发现，retrofit2支持的可以取消请求，其实用的就是okhttp3的cancel方法。同理，同步请求也是一样的，也是调用了代理的OkHttpCall的方法，只不过是execute方法，这个方法里面没有回调，和异步不同，是直接返回解析好的Response对象的，这就是同步请求啦。至此，顺着构建请求对象→构建请求接口→发起同步/异步请求这个流程，我们分析了一遍retrofit2到底是如何实现的。最后再说几句retrofit2主模块源码其实并不是很多，我感觉用的最巧妙的就是create方法的动态代理，然后加上运行时注解来构建API，深度结合okhttp3，使得网络请求的构建变得非常简洁，并且功能强大，而且安全。retrofit2同时支持与rxjava配合使用，是通过设置adapter来实现的，retrofit2把adapters和converters从主代码里拆分出来了，相当于组件化的意思，如果需要使用，就由开发者自己引用并定义，这种组件化的思想我觉得也非常棒。retrofit2源码里是通过junit来写测试的，测试代码写的也非常好，更说明了优秀的代码离不开优秀的测试，这也是值得我们学习的地方。这是我第一次自己去分析一个开源项目的源码，也许可能会有遗漏的地方，望指出，抛砖引玉，谢谢~]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native-APP-With-Testing]]></title>
    <url>%2F2016%2F05%2F28%2FReact-Native-APP-With-Testing%2F</url>
    <content type="text"><![CDATA[这两天，我尝试了一下在开发react-native app的过程中如何去组建一套比较容易理解和使用的测试框架进行UT和component UT，这里做一下整理。PS：最终代码在reading项目中, 欢迎关注。为何要尝试UT其实我接触UT部分，也就是这两天。如今很多人都知道TDD的开发模式，由测试来驱动开发，优秀的代码是离不开优秀的测试的。在产品快速迭代的过程中，我们很容易忽略测试这一重要的环节，目前公司里我负责的app正好就处在这个状态。很多问题是测试很难测出来的，尤其在资源紧张的情况下，我认为，需要研发工程师使用UT来尽可能保证质量，并且在已有的功能重构和回归方面，通过各种工具手段来减少测试资源的占用。注：本文只谈react-native app的测试。在对蜂鸟众包app中react-native部分添加UT之前，我使用了reading项目先进行一些了解和踩坑。Jest我对js方面的测试框架不太了解，对react-native相关的就更不了解了。Jest这个框架是我看到react-native源码中有使用，所以按照react-native源码中的配置，我进行了尝试。具体细节在reading的try jest这次提交中，整个配置我也是各种尝试，因为引用react-native作为框架开发的项目毕竟和依赖react-native源码中测试的配置部分有不少不同的地方，经过各种尝试，我按照fb的方式跑起来了一个测试用例，感觉对我来说有点晦涩……Jest我看了下是个挺全面的框架，包括断言、mock等部分，而且在做component UT的时候，我感觉有些麻烦，用到了好多react-dom的东西。也许是博大精深我不太会用，之前也没有怎么了解过这个，就想寻求一种相对更简单交互更好的方式。Mocha &amp; Enzyme &amp; ChaiMocha是我之前有稍微看过一下下的（其实就是看过官方主页），感觉很简洁，很方便的样子。Chai是一个很简洁的断言库，可以和Mocha结合做非UI代码的UT。关于react-native component UI部分的UT，我发现用Enzyme的很多，这是airbnb开源出来的一个react的js测试库，可以结合Mocha，同时可以结合react-native一起用，看起来也挺简洁的，所以我就想把这三个结合到一起用。下面就详细讲一下这种方式吧，以reading项目为例。这里我在写测试代码的时候，为了和项目代码保持一致，统一采用ES6.首先需要安装以下依赖1npm i babel-core babel-preset-es2015 babel-preset-react-native chai enzyme mocha react-addons-test-utils react-dom react-native-mock --save-dev添加.babelrc文件123&#123; &quot;presets&quot;: [&quot;es2015&quot;, &quot;react-native&quot;]&#125;配置测试脚本1234&quot;scripts&quot;: &#123; ... &quot;test&quot;: &quot;mocha --require react-native-mock/mock.js --compilers js:babel-core/register --recursive your_app/**/*/*.spec.js&quot; &#125;,这种配置路径your_app/**/*/*.spec.js&quot;是表示在app目录下的两层目录下后缀为.spec.js的均为测试代码，这是根据我reading的路径来走的，你可以根据你自己项目的具体路径来配置。编写第一个测试代码这里我第一个写的非常简单的测试用例是给reading中Button组件写的，代码如下：123456789101112131415'use strict';import React from 'react';import &#123;View, Text, StyleSheet&#125; from 'react-native';import &#123;shallow&#125; from 'enzyme';import &#123;expect&#125; from 'chai';import Button from '../Button';describe('&lt;Button /&gt;', () =&gt; &#123; it('it should render 1 Text component', () =&gt; &#123; const wrapper = shallow(&lt;Button /&gt;); expect(wrapper.find(Text)).to.have.length(1); &#125;);&#125;);这里例子非常简单了，其实就是检测一下Button这个组件中是否渲染了一个Text组件。然后执行脚本：1npm test你就会看到非常人性化的输出了：12345678910111213~/workspace/reading master ✔ 23h37m▶ npm test&gt; reading@0.1.5-rc test /Users/richardcao/workspace/reading&gt; mocha --require react-native-mock/mock.js --compilers js:babel-core/register --recursive app/**/*/*.spec.js &lt;Button /&gt; ✓ it should render 1 Text component 1 passing (393ms)到这里，本文就结束了。关于TDD和自动化测试这部分，我基本了解的也不多，所以本文也只是针对入门级想尝试对react-native做UI的同学参考。后续首先，我是一个连测试用例都不会写的菜鸡，但是我一直觉得开发写UT是挺有必要的，也是结合我目前遇到的情况总结出来的，慢慢的我会学一些自动化测试相关的内容，从reading开始，尽量慢慢向TDD模式转化，也会在公司内部用起来。抛砖引玉，有什么好想法的同学，欢迎交流。本文相关详细代码请看reading项目。]]></content>
      <categories>
        <category>testing</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reading App Write In React-Native]]></title>
    <url>%2F2016%2F02%2F06%2FReading-App-Write-In-React-Native%2F</url>
    <content type="text"><![CDATA[reading项目开源地址：https://github.com/attentiveness/readingReading App Write In React-NativeNo Profit, No Advertisement, Only Feelings这是一个产品级的开源项目（请允许我这么说）。Init打开我的git log看了看，创建reading项目的时间是2015年12月11日上午1:00，我依然记得那时候我的初衷是想做一个react-native为主导开发的APP。从刚开始学js到做公司android项目中react-native模块的开发还不到一个月，我想，能否用react-native为主导开发一个自己的APP来慢慢学习呢？于是我就init了reading项目放到了我的github上，还专门建了一个organization叫attentiveness，愉快的装了一逼。但是到2015年12月13日下午3:15的时候，我更新了一发commit就暂停了。因为当时我还不知道应该怎么去写代码，我都不知道js的代码规范是怎么样的，我也不知道做reading到底需要做什么需求，在迷茫之中，我停止了reading项目的开发。Restart当我重启reading项目的时候，记录显示时间是2016年1月25日上午1:24。为什么重启reading项目？其实很简单，之前搁置的原因就是我不知道到底要做什么需求，到底应该如何去做，也不知道代码怎样去写。截止16年1月25日的时候，正好是我做公司的react-native项目刚满一个月的日子，我已经知道了如何去写代码，如何去做一个项目，所以我重启了reading项目。需求哪里来？我的一个小伙伴想做产品经理，但是他以前根本没有经验，那就一起学。需求就这么来了，于是我们就说干就干了。0.1.20.1.2是Reading app发布市场的第一个版本。为什么是0.1.2？因为0.1.1是reading的内测版本，内测平台我选择了蒲公英。说实话，这是我第一次打react-native开发的app的release包，第一次把一个自己认为称得上是项目的app发布到了应用市场。360市场下载地址：Download Reading豌豆荚下载地址：Download ReadingReact-Native Android类似弹窗效果的实现在react-native ios中，可以用Modal组件实现这个效果，但是官方文档中明确注明了这个组件是This component is only available in iOS at this time.OK，那android怎么办？从官方的Known Issues中可以看到，官方有让Modal组件支持android的计划，但是这个版本是没有的，现在最新版本0.19.0的release note中也是没有的，但是reading app要上线第一个版本，就必须实现分享的弹窗。当时考虑有两种方案：dialog和spinner。官方组件是有dialog的，这个组件是Alert，但是这个组件并不支持自定义UI，只是固定的样式模板，那么无法实现我这个需求。spinner组件官方还没支持，并且明确了以后会支持，所以我想到了能不能有android可以使用的类似Modal的组件呢？于是我找来找去，还真有，官方文档中并未提及，这个组件的名字叫Portal。组件找到就好办了，于是我开始动手实现。首先引入Portal：1import Portal from &apos;react-native/Libraries/Portal/Portal.js&apos;;引入之后，我看了下Portal，使用起来也挺简单，虽然没有文档，但是可以看到，我能用到的有这么几个方法allocateTagshowModalcloseModalgetOpenModals那么就简单了，引入之后我需要12345componentWillMount() &#123; if (Platform.OS === &apos;android&apos;) &#123; tag = Portal.allocateTag(); &#125; &#125;拿到tag之后123onActionSelected() &#123; Portal.showModal(tag, this.renderSpinner()); &#125;这里的onActionSelected是ToolbarAndroid的一个属性，可以触发点击action的事件，我的分享按钮就在右上角，那么点击之后，分享的弹窗就出现了。那么如何关闭？我这里做的比较简单，是这样的12345678910goBack() &#123; if (Portal.getOpenModals().length != 0) &#123; Portal.closeModal(tag); return true; &#125; else if (canGoBack) &#123; this.refs.webview.goBack(); return true; &#125; return NaviGoBack(this.props.navigator); &#125;然后1234567componentDidMount() &#123; BackAndroid.addEventListener(&apos;hardwareBackPress&apos;, this.goBack); &#125; componentWillUnmount() &#123; BackAndroid.removeEventListener(&apos;hardwareBackPress&apos;, this.goBack); &#125;这个UI怎么像是一个弹窗呢？其实技巧就在于背景颜色上面。我的分享View是居中的，背景颜色我用了rgba设置了透明度，就像是这样1backgroundColor: &apos;rgba(0, 0, 0, 0.65)&apos;那么就非常像一个弹窗啦~具体效果可以看这里Release Note与线上事故复盘针对这部分，我也在项目中专门写了这两个文档，具体可以看Reading Release NoteRelease线上事故复盘文档会根据实际情况保持更新，这是reading自己的积累。敏捷开发git工作流我就不在这里赘述了，大家可以参照A successful Git branching model。在0.1.3版本上线之后，我们发现我们需要开发流程，之前流程的不规范导致我们工作效率不高并且容易遗漏很多东西，所以我采用了最简单的敏捷开发流程，我们使用Tower进行协同，为什么选择Tower？与微信绑定，使用方便有敏捷开发板，可以构建简易的敏捷开发，防止需求遗漏，还可以进行问题讨论等，管理非常方便，也是现在reading正需要的没有多余的冗杂功能，reading现在还很小，这就足够了，简约而不简单这是我们目前的Reading敏捷开发板展示，可以看到我们已经在计划做0.1.4版本的需求了最后再说几句欢迎大家star，fork，pr，issue，和reading、和我们一起成长~目前只发布了360市场和豌豆荚，360市场审核快一些，apk版本更新之后我会及时发布市场提交审核的，当然reading中也是有自己的热更新哒，react-native你懂得。针对reading项目我采用的热更新方案是Microsoft/react-native-code-push，因为reading是没有后端的，所以code-push项目完美的帮我解决了热更新的jsbundle版本管理发布问题。目前Reading线上只有android版本，功能稳定之后我会做ios的兼容，并且有发布到AppStore的计划。Reading会持续更新下去的，希望能得到大家的支持和鼓励。你们的鼓励是我们前进的动力！]]></content>
      <categories>
        <category>open source</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逝去的2015]]></title>
    <url>%2F2016%2F01%2F17%2F%E9%80%9D%E5%8E%BB%E7%9A%842015%2F</url>
    <content type="text"><![CDATA[2015这一年，我从学校走进了社会，基本完成了从学生到职场人士的转型，想想感觉自己都老了。这一年感悟很多，经历了很多事，一路走来，也是充满了坎坷。收获良多，写下随笔。生活不只是眼前的苟且，还有诗和远方。随笔大概包括这几部分内容：学校的大四生活坚持了四年至今仍在继续的爱情长跑初入职场这半年的人和事最后再说几句学校的大四生活大四虽然课少了，但是心里想的事情就不只是课程和学校的事情了，说大四是大学四年最愁的一年完全不为过。还记得大四的时候，我和同学在一个坑爹的小地方给人家写代码，一个月挣1500糊口，也就2个月就逃出来了。那时候大家考研的考研，工作的已经去实习了，我真是要什么没什么。本来想考研，报了班，学了一个暑假发现还是不会做题，我确实是不适合啃书本的人。于是不顾家里反对，偷偷自己做自己想做的事情。从大三开始自己搞搞Android app开发，当时只是感兴趣，从刷机开始，慢慢做了apk美化，结果就想知道app是如何开发出来的，就开始摸索着做了。刚开始就报名参加了一个比赛，记得还是一个全国性的比赛，当时真心是搭个Android开发环境都要三天，都是从网上copy的代码，堆了一个能吹一吹和摇一摇的玩意就去参赛了……那时候我都不知道比赛是怎么个意思，也没报什么希望。平平淡淡了过了一个月之后，学校老师突然打电话给我说，我做的那个玩意得了全国三等奖……我直接就兴奋了，觉得自己很厉害，新手还能拿全国奖，那时候真是自信心爆棚，仿佛感觉什么app都能写出来的样子~之后又参加了一个比赛，还都是我带队，也拿了奖，给学校争了光。真心感觉喜欢做一件事，在有兴趣支撑的同时，还需要有成就感来推动自己更努力的学习。之后仿佛就感觉有点顺理成章的样子，我果然没考研，继续做了Android，跟着一个对我很好的导师做一个国家级的项目，陆陆续续加上毕设一共做了1年，最后顺利结项，确实学到了很多东西，收获很多，也是我对自己大学最满意的一件事情了。毕设是团队毕设，我带队，这是我最满意的一次带队，每个人都很努力，我们也做出了很不错的成果，大概还有两三个国家发明专利这样子。大四这一年，不光锻炼了我自己的工程能力，更多的锻炼了我思考问题、与人沟通、项目管理等能力，从思想上算是一次量变积累质变吧，有种整个人升华了一次的感觉~运气或许也是能力的一部分，能遇到一位对自己有知遇之恩的导师很难得。有了这些经历，也是我运气好，成功拿到了饿了么上海研发中心的实习offer，在这期间也发生了实习前面阿里被拒，实习后面阿里拿到offer但是没去，说明实习了三个月我真的成长了不少，没去阿里的原因也比较简单，我确实很喜欢饿了么的这种比较open的环境，同事们都很nice，我有问题请教他们，他们都会很耐心的教我。阿里我也很喜欢的，当时拿到的是天猫杭州的offer，面试官给我打了2小时的电话，感觉人真的很nice，现在我还和他保持着联系，有问题也会请教阿里的朋友们，他们都会尽量给我提供帮助，我算是与阿里结下了不解之缘。身边的朋友很重要，他们给你提供的帮助可以让你少走很多弯路，请珍惜身边的朋友和对你好的人。坚持了四年至今仍在继续的爱情长跑我是从大一谈的妹子，确实蛮早的……军训时候追到的哈哈~和我家妹子一起经历了很多事，从2016年开始就是我们第五年的爱情长跑了，我也相信我们能走到最后。大学时候谈恋爱，可以让一个男孩子慢慢变得成熟起来，但是好女孩可遇而不可求，遇到了请珍惜。大一大二，那时候我和我家妹子，可以说三天小吵两天大吵，不吵架都过不去日子的那种……期间分手了起码十几次，搞得最后同学们都不相信我们会分手了，甚至室友都开始拿这个打赌了……两个人在一起需要相互磨合，我和我家妹子磨合的时间其实算比较长的，用了2年时间吧，才慢慢稳定下来，当时两个人都经常犯傻，做了好多啥事，也矫情也作，看来恋爱中女人智商为零，男人智商直接为负了。我做的那些我现在看来很幼稚的事情我都不好意思说……毕业季分手季，这句话大家都不陌生，但是我和我家妹子跨过了这道坎，走到了现在。我来上海实习工作，她为了和我在一起，也来到了上海工作。对她来说上海是一个陌生的没什么亲人的城市，只是因为我在这里，所以她来了。为了我们以后能生活的更幸福，能在上海有属于我们自己的家，我也要努力奋斗，这给我很大的动力。恋爱的两个人都要为对方付出，才能走得更远，一旦天平倾斜，那么有可能面临危机。其实让我这么坚定想娶我家妹子的原因很简单：她用她最美好的青春年华陪伴了我这个一无所有的屌丝，我还有什么理由不对她好呢。这年头，不拜金不物质愿意陪着一个一无所有的人一起打拼的妹子真的很少很少了。我大一大二迷恋玩游戏，LOL，成绩挂科好几门，还白天不上课晚上包夜之类的……她也没放弃我，一直想办法让我“改邪归正”，直到大二末我才醒悟过来。这期间她一直在劝我、鼓励我，不顾别人异样的眼光和闲言碎语，我真的太感动。当时没觉得，后来越想越感动，发誓对她好，不辜负她，让我们生活的更幸福，更快乐。爱情是需要两个人共同经营的，只要真心实意的对对方好，总有办法可以克服困难走下去。和我家妹子一起的美好回忆太多，每次想起来都有满满的幸福感，我们一起逗比，一起旅行，失落的时候互相安慰，得意的时候一起嘚瑟，一般总是我嘚瑟然后我家妹子敲打我……我们互相鼓励，一起向着美好的未来努力。我们都不笨，我相信我们可以的！作为一个男人，要有责任感，让自家妹子有安全感，肩上的担子很重但是要顶起来。最后说一句，如果你遇到了一个像我家妹子这样的妹子，请珍惜。初入职场这半年的人和事7月份大学毕业，加上之前实习了三个月表现不错，顺利转正。初入职场的我什么都不懂，到处都需要学习。还好有一群很棒的同事给我提供各种帮助，而且带我的老大jinyang大哥超级赞，他只比我大一岁，感觉和我很像，都是想法比较多的人。在平时工作的时候，他会根据我的兴趣给我分配一些工作任务，不断的锻炼我成长。我喜欢尝试新的挑战，他就把具有挑战性的任务分配给我，而且从不给我什么压力，让我感到很轻松，没有什么太大的压力。从刚转正到现在，我总感觉就算我搞不定的事情，他也能搞定，所以我完全不担心啊哈哈哈。论一个好leader的重要性。我们的团队氛围真的很好，没有什么上下级之分，大家都是同事，都是好朋友，一起吃饭一起讲段子嘿嘿嘿，有困难的时候也会互相帮助，一起加班一起发版本，而且也很少和产品经理撕逼……一个月前我们这边Android组新来了一个实习生zhaoxuan，大哥让我带。zhaoxuan很聪明，而且经常问问题，我们经常一起交流，性格也很好，很不错的实习生，学习能力蛮强的，经常能针对问题提出自己的看法。作为一名Android developer，他在UI方面还是蛮有讲究的，自己会私下研究一些东西，自主学习，很有潜力。在带实习生的过程中，间接的对我也是一个锻炼，这也是大哥对我的锻炼。团队氛围很关键，开心的工作一定是高效率的。前几天和大哥聊天，他肯定了我这半年的表现，说我确实表现出色，将才，很感动。我是一个非常希望通过自己的努力获得肯定的人，我学习能力不弱，想法也不少，我会继续努力让自己变得更强，能承担起更多的责任。对自己要有信心，这也是周围的朋友教会我的道理。人不能妄自菲薄，也不能狂妄自大，要做到不吹不黑，平心而论。只有通过自己的努力才能获得他人的肯定，脚踏实地。最后再说几句运气有时候挺关键的，但是自己不努力任何运气都没有。美好的爱情可遇而不可求，遇到好女孩请珍惜，男人年轻时可以穷，但是要变成熟，要有上进心、责任感、使命感。互联网公司更看重一个人的潜力，包括沟通能力、学习能力、责任心和人品等等，你现在的能力不能决定你的未来。正确的认识自己很重要，人贵在有自知之明，摆正自己的位置，挖掘自己的潜力，才能更好更快的向前跑。2016年已经到来，新的一年，继续奋斗，为了美好的未来！不要让身边的人对自己失望。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>2015个人总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native With Redux]]></title>
    <url>%2F2016%2F01%2F12%2FReact-Native-With-Redux%2F</url>
    <content type="text"><![CDATA[经过上次的react-native小模块完成之后，发现不少缺点，而且基本没什么扩展性。这次正好又增加一个react-native模块————我的等级特权，于是动手重构了项目里整个react-native的部分，随着今晚项目发布上线，动手记录下来这次重构的经验。本文目录为什么要做这次重构Flux模式与ReduxReact-Native With Redux代码规范和语法糖重构过程中遇到的坑总结撰写本文时笔者的相关环境如下操作系统：OS X 10.11.2npm中react-native版本：0.17.0Android studio中react-native版本：0.17.1为什么要做这次重构之前的初次踩坑文章是在做第一个react-native需求——通知中心的时候写的，当时为的是功能没问题然后上线，并没有考虑扩展、封装、数据流等问题。当又要添加其他react-native模块的时候，就必须要解决这样的问题了，于是这次重构应运而生。Flux模式与ReduxFlux模式首先，我们知道，react-native根据什么render UI呢？答案就是state和props。那么可以预料到，当模块增多、代码量增加的话，如果没有一套数据流规范，那么就会遇到state或props不统一导致刷新错乱等问题。react是遵循Flux架构的，那么什么是Flux呢？这里我们看一张图：Store包含了应用的所有数据，Dispatcher替换了原来的Controller，当Action触发时，决定了Store如何更新。当Store变化后，View同时被更新，还可以生成一个由Dispatcher处理的Action。这确保了数据在系统组件间单向流动。当系统有多个Store和View时，仍可视为只有一个Store和一个View，因为数据只朝一个方向流动，并且不同的Store和View之间不会直接影响彼此。(这段话引用自Facebook：MVC不适合大规模应用，改用Flux)Redux那么Redux是什么呢？Redux是javascript状态容器，提供可预测化的状态管理，可以构建一致化的应用，除了和React一起用外，还支持其他界面库，体积小（只有2kb）而且没有任何依赖。Redux由Flux演变而来，但是避开了Flux的复杂性，上手快，使用简单，而且社区活跃，是目前主流的Flux数据流框架。关于Redux文档可以看英文原版和中文翻译版。从这里开始，默认读者已经阅读过Redux文档，有Redux基础。React-Native With Redux我的package.json中引用的模块有：12345678&quot;dependencies&quot;: &#123; &quot;immutable&quot;: &quot;^3.7.5&quot;, &quot;react&quot;: &quot;^0.14.3&quot;, &quot;react-native&quot;: &quot;^0.17.0&quot;, &quot;react-redux&quot;: &quot;^3.1.0&quot;, &quot;redux&quot;: &quot;^3.0.5&quot;, &quot;redux-thunk&quot;: &quot;^1.0.2&quot; &#125;redux目前的最新版本3.0.5是基于react 0.14的，所以同时加入react和redux，react-redux是Redux的react绑定库，redux-thunk是为了实现异步Action Creator引入的。下面我以请求用户等级特权数据并刷新UI为例梳理一遍整个数据流，包含Action，Store，Reducer三个重要概念。首先，定义请求用户等级特权数据的ActionType：react-native/constants/ActionTypes.js1export const FETCH_RANK_LIST = 'FETCH_RANK_LIST';那么FETCH_RANK_LIST就代表了要执行请求等级特权数据的动作类型。然后开始定义Action：react-native/actions/rank.js1234567891011121314151617181920212223242526272829303132333435'use strict';import * as types from '../constants/ActionTypes';import &#123;LEVEL_PRIVILEGES&#125; from '../constants/Urls';import &#123;request&#125; from '../utils/RequestUtils';import &#123;ToastShort&#125; from '../utils/ToastUtils';export function fetchLevelPrivileges() &#123; return dispatch =&gt; &#123; dispatch(fetchRankList()); request(LEVEL_PRIVILEGES, 'get') .then((rankList) =&gt; &#123; dispatch(receiveRankList(rankList)); &#125;) .catch((error) =&gt; &#123; dispatch(receiveRankList([])); if (error != null) &#123; ToastShort(error.message) &#125; &#125;) &#125;&#125;function fetchRankList() &#123; return &#123; type: types.FETCH_RANK_LIST, &#125;&#125;function receiveRankList(rankList) &#123; return &#123; type: types.RECEIVE_RANK_LIST, rankList: rankList &#125;&#125;这里的Action是异步的，因为请求是异步的。其实意思很简单，通过fetchLevelPrivileges请求了后端数据，异步获取了数据之后进行数据的接收，触发了接收数据的Action：RECEIVE_RANK_LIST，请求和接收其实是一个连续的动作。那么定义完Action之后，就需要定义Reducer了：react-native/reducers/rank.js123456789101112131415161718192021222324'use strict';import * as types from '../constants/ActionTypes';const initialState = &#123; loading: false, rankList: []&#125;export default function rank(state = initialState, action) &#123; switch (action.type) &#123; case types.FETCH_RANK_LIST: return Object.assign(&#123;&#125;, state, &#123; loading: true &#125;); case types.RECEIVE_RANK_LIST: return Object.assign(&#123;&#125;, state, &#123; loading: false, rankList: action.rankList &#125;) default: return state; &#125;&#125;可以看到initialState是初始的状态，然后通过不同的type来更新state。这里state是全新的state，并不是在已有state的引用上改变数据，关于这点Redux的文档中有详细的解释，这里不再赘述。简单的reducer定义好之后，我们要开始定义Store了：react-native/store/configure-store.js12345678910111213'use strict';import &#123;createStore, applyMiddleware&#125; from 'redux';import thunkMiddleware from 'redux-thunk';import rootReducer from '../reducers/index';const createStoreWithMiddleware = applyMiddleware(thunkMiddleware)(createStore);export default function configureStore(initialState) &#123; const store = createStoreWithMiddleware(rootReducer, initialState); return store;&#125;这里使用了redux-thunk来支持异步Action，Middleware提供的是位于action发起之后，到达reducer之前的扩展点，这是一个比较重要的概念，具体请看redux文档理解。rootReducer是最终合并后的reducer：react-native/reducers/index.js123456789101112'use strict';import &#123;combineReducers&#125; from 'redux';import notice from './notice';import rank from './rank';const rootReducer = combineReducers(&#123; notice, rank&#125;)export default rootReducer;这里用到了redux的combineReducers函数，将多个模块的reducer合并成一个。最后我们需要串通整套数据流，我们需要做的是：react-native/root.js12345678910111213141516171819import React from 'react-native'import &#123;Provider&#125; from 'react-redux/native'import configureStore from './store/configure-store'import App from './containers/app'const store = configureStore();class Root extends React.Component &#123; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &#123;() =&gt; &lt;App /&gt;&#125; &lt;/Provider&gt; ) &#125;&#125;export default Root;这非常关键，root.js是index.android.js注册的唯一入口，通过Provider组件讲store注入进整个app，至此，整套数据流就串通起来了。那么串通起来是怎么样的呢？我来描述一下：用户点击进入等级特权页面，通过action中fetchLevelPrivileges做了请求数据的动作，然后dispatch了FETCH_RANK_LIST这个动作，触发了reducer更改state，刷新UI（此时应该是loading界面）；然后当数据请求完成之后dispatch了RECEIVE_RANK_LIST这个动作，接收到请求获取的数据，触发了reducer更改state，再刷新UI（此时应该展示完整页面）。这样数据流就非常清晰了：Action =&gt; Dispatcher =&gt; Store =&gt; View。当用户进行其他操作时，由View发起Action，继续这个单向的数据流，这样就完成将Flux单向数据流的思想通过Redux融入React-Native项目当中了。将Flux的思想应用于项目之中，确实感觉思路清晰，写起来心里踏实。代码规范和语法糖由于我是菜鸟，所以我在写的时候严格遵循了Airbnb React/JSX Style Guide，相信大厂应该没错的。语法糖我全部使用了ES6，因为react-native已经使用了Babel完全支持了ES6语法糖，可以使用ES6的新特性，而且我感觉ES6对于我来说更容易理解，因为我是个写Java的Android Developer……重构过程中遇到的坑这里我要说明一点：使用Chrome调试react-native非常重要！在重构的过程中，我都是通过debug来观察数据流，看哪一环出现了问题再去解决。还有一个大坑！当手机开启手势触摸选项之后，在react-native页面，同时用三个或三个以上手指触摸上去你就会发现……crash了。iOS我没测试过，这个是我在Android机器上发现的问题，然而官方并没有解决办法，我安装了react-native官方的showcase案例的一个app，发现该问题同样存在。。。所以我只好提了issue。还好这种情况很少，目前没有接到线下类似这样的crash反馈，估计是很多手机是不带手势触摸的，而且估计很多用户不会开启手势触摸，其实我用Android手机的时候一直没开过……在我写这篇文章的时候react-native 0.18.0-rc已经发布了，但是并没有看到修复类似的bug，不过0.18应该是一个相对较大的更新，react-native-cli也更新到了0.1.10，Android里react-native的依赖库也更新到了0.18.0版本，我打算等react-native发布0.18.0 release版本之后进行一次整体更新，继续踩坑……总结对于我这个菜鸟来说，这次重构+新功能开发确实是有惊无险。总结一下：所有action的定义都放在action包中，reducer放在reducers包中，store放在store包中，入口依然是index.android.js，只不过注册的时候直接指向root.js，通过root将store注入到app当中，所有的模块都包一层containers，在这里进行connect:react-native/containers/RankContainer.js123456789101112131415161718192021222324'use strict';import React from 'react-native';import &#123;connect&#125; from 'react-redux/native';import Rank from '../components/Rank';class RankContainer extends React.Component&#123; render() &#123; return ( &lt;Rank &#123;...this.props&#125; /&gt; ) &#125;&#125;function mapStateToProps(state)&#123; const &#123;rank&#125; = state; return &#123; rank &#125;&#125;export default connect(mapStateToProps)(RankContainer);这里可以看到，所有的页面都是组件，这里的&lt;Rank /&gt;就是等级特权页面组件，包括自定义控件等组件全部放入components包中，于是整个工程被组件化了，更容易与iOS进行融合。然后在utils包中定义utils，constants包中写了ActionTypes和Urls。在新增模块的时候，思路已经非常清晰了，其实就是做填空题：在ActionTypes中添加动作定义，在actions中定义Action，在reducers中定义reducer，然后在containers中写好容器外壳，最后在components中写组件，个人感觉是可扩展的弹性小架构，思路、封装、数据流、组件等等都比较清晰，目前这就是我重构之后的样子了。因为这些都是我一个人摸索的，等与公司的web工程师们交流时他们或许会给出更好的建议，期待ing~~最后附上我的工程目录(IDE: Sublime Text 3)：至此，本文结束。欢迎大家互相交流讨论。我只是菜鸡，抛砖引玉~]]></content>
      <categories>
        <category>hybrid</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native Android 热更新]]></title>
    <url>%2F2015%2F12%2F03%2FReact-native-Android-%E7%83%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[继上次React-native Android 初次踩坑之旅的分享之后，这次分享的内容是React-native Android 热更新实现。本文目录：网上已知方案分析与发现新的热更新方案撰写本文基于的开发环境：操作系统：OS X 10.11.1react-native Android版本：0.16.0npm中react-native版本： 0.16.0-rc网上已知方案首先说下网上已有的方案，这是我找到的方案，并且测试确实可以热更新的：React-Native-Remote-Update。简述下这个方案实现热更新原理是反射调用了ReactInstanceManagerImpl中的如下方法：1234567891011121314151617private void recreateReactContextInBackground( JavaScriptExecutor jsExecutor, JSBundleLoader jsBundleLoader) &#123; UiThreadUtil.assertOnUiThread(); ReactContextInitParams initParams = new ReactContextInitParams(jsExecutor, jsBundleLoader); if (!mIsContextInitAsyncTaskRunning) &#123; // No background task to create react context is currently running, create and execute one. ReactContextInitAsyncTask initTask = new ReactContextInitAsyncTask(); initTask.execute(initParams); mIsContextInitAsyncTaskRunning = true; &#125; else &#123; // Background task is currently running, queue up most recent init params to recreate context // once task completes. mPendingReactContextInitParams = initParams; &#125; &#125;然后通过自定义JSBundleLoader将bundle指向的文件重定向，反射调用这个方法就可以实现热更新，重新加载重定向之后的bundle文件，这个bundle文件就是从服务端下载好的。这个方案是通过反射调用private方法实现的热更新，在我看来还是有些不安全的，Facebook没把这个方法public应该是有原因的，可能他们没想用这种方法去公开的实现热更新，那么也许在迭代的过程中，可能这个反射调用的方法就失效了，那么我认为用这个方案做线上的热更新是不太安全的。分析与发现在更新react-native Android版本之后，我发现在ReactInstanceManager.Builder中有这么一个方法可以使用：123456789/** * Path to the JS bundle file to be loaded from the file system. * * Example: &#123;@code "assets://index.android.js" or "/sdcard/main.jsbundle&#125; */ public Builder setJSBundleFile(String jsBundleFile) &#123; mJSBundleFile = jsBundleFile; return this; &#125;看这个注释，意思就是可以通过这个方法实现bundle文件的重定向。也就是说，我们可以通过这个方法来实现热更新。具体思路继续往下看，其实挺简单。新的热更新方案首先，看更改之后的ReactInstanceManager单例变成什么样子了：123456789101112131415161718192021222324252627/** * Created by caolicheng on 15/11/12. */public class CrowdReactInstanceManager &#123; public final static String MODULE_NAME = "CrowdReactApp"; private CrowdReactInstanceManager() &#123; &#125; public static ReactInstanceManager getInstance() &#123; return Holder.sInstance; &#125; private static class Holder &#123; private static ReactInstanceManager sInstance = ReactInstanceManager.builder() .setApplication((Application) ElemeApplicationContext.getContext()) .setJSMainModuleName("react-native/index.android") .addPackage(new MainReactPackage()) .addPackage(new CrowdReactPackage()) .setUseDeveloperSupport(BuildConfig.DEBUG) .setInitialLifecycleState(LifecycleState.RESUMED) .setJSBundleFile(ReactJsBundleInstanceManager.getInstance().getJSBundleFile()) .build(); &#125;&#125;可以很清晰的看到，之前的setBundleAssetName方法被删除了，取而代之的是setJSBundleFile方法，里面是ReactJsBundleInstanceManager这个单例，从这个单例中直接拿出bundle文件路径，相当于bundle被重定向了。我们再看看这个ReactJsBundleInstanceManager到底是个什么：1234567891011121314151617181920212223/** * Created by caolicheng on 15/12/2. */public class ReactJsBundleInstanceManager &#123; public static final String BUNDLE_NAME = "index.android.bundle"; private ReactJsBundleInstanceManager() &#123; &#125; public static JSBundleManager getInstance() &#123; return Holder.sInstance; &#125; private static class Holder &#123; private static JSBundleManager sInstance = new JSBundleManager.Builder() .setBundleAssetName(BUNDLE_NAME) .setAssetDir(ElemeApplicationContext.getContext().getFilesDir()) .setEnabled(!BuildConfig.DEBUG) .build(); &#125;&#125;我们很明显的看到了这是一个叫JSBundleManager这个东西的单例，这个东西设置了bundle的名字、bundle的父文件路径、在release时候启动更新。也就是说，JSBundleManager中完成了react-native热更新的逻辑，说白了就是：下载新的bundle，替换旧的bundle。那么来了一个问题：因为ReactInstanceManager是个单例，也就是说，setJSBundleFile的路径一开始就已经固定了，那么如果我们把bundle文件打包在assets文件夹下的话，就要在一开始的时候把assets文件目录下的bundle文件copy一份到我们的热更新bundle的路径下，类似这样：12345678910public void initReactNative() &#123; if (PreferenceManager.isFirstStart()) &#123; try &#123; File bundle = new File(ReactJsBundleInstanceManager.getInstance().getJSBundleFile()); IOHelpers.saveStream(getAssets().open("index.android.bundle"), bundle); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;react-native热更新就完成了。这里我把我的JSBundleManager代码贴出来，这部分其实是最关键的，但是我的代码没法直接使用，只是告诉大家一个思路：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public class JSBundleManager &#123; public static final String BUNDLE_VERSION = "bundle_version"; private static final String DEFAULT_BUNDLE_VERSION = "0.0.0"; private final String mBundleAssetName; private final Callback mCallback; private final Boolean mEnabled; private final File assetDir; private Upgrader upgrader; JSBundleManager(@NonNull String bundleAssetName, @NonNull File bundleDir, @Nullable Callback callback, @Nullable Boolean enabled) &#123; mBundleAssetName = bundleAssetName; mCallback = callback; mEnabled = enabled; assetDir = new File(bundleDir, "assets"); upgrader = new Upgrader(); &#125; public String getJSBundleFile() &#123; File assetFile = new File(assetDir, mBundleAssetName); if (assetFile.exists()) &#123; return assetFile.getAbsolutePath(); &#125; return "assets://" + mBundleAssetName; &#125; //获取bundle版本号 public String getBundleVersion() &#123; return SharedManageUtils.getString(BUNDLE_VERSION, DEFAULT_BUNDLE_VERSION); &#125; public JSBundleManager checkUpdate(AppVersion appVersion) &#123; if (mEnabled == null || mEnabled) &#123; checkAndDownloadUpdate(appVersion); &#125; return this; &#125; private void downloadBundle(final AppVersion appVersion) &#123; ReactUpdateInfo reactUpdateInfo = new ReactUpdateInfo(ElemeApplicationContext.getContext()); reactUpdateInfo.setDownloadUrl(appVersion.getDownloadUrl()); upgrader.upgrade(reactUpdateInfo, new DownloadProgressListener() &#123; @Override public void onProgressChanged(int progress) &#123; if (mCallback != null) &#123; mCallback.onDownloading(); &#125; &#125; &#125;, new DownloadResultListener() &#123; @Override public void downloadSuccess(DownloadFile file) &#123; try &#123; File bundle = new File(getJSBundleFile()); if (bundle.exists()) &#123; bundle.delete(); &#125; FileUtil.copyFile(file.getFile(), new File(assetDir.getPath(), mBundleAssetName)); SharedManageUtils.set(BUNDLE_VERSION, appVersion.getLatestVersion()); &#125; catch (IOException e) &#123; if (mCallback != null) &#123; mCallback.onError(e); &#125; e.printStackTrace(); &#125; finally &#123; FileUtil.deleteFile(file.getFile()); &#125; if (mCallback != null) &#123; mCallback.onUpdateReady(); &#125; &#125; @Override public void downloadFail(Exception e) &#123; if (mCallback != null) &#123; mCallback.onError(e); &#125; &#125; &#125;); &#125; private void checkAndDownloadUpdate(AppVersion appVersion) &#123; if (appVersion.isUpdate()) &#123; downloadBundle(appVersion); &#125; else &#123; if (mCallback != null) &#123; mCallback.onNoUpdate(); &#125; &#125; &#125; public interface Callback &#123; void onDownloading(); void onError(Exception e); void onNoUpdate(); void onUpdateReady(); &#125; public static class Builder &#123; private String mBundleAssetName; private File mAssetDir; private Callback mCallback; private Boolean mEnabled; public Builder setBundleAssetName(@NonNull final String bundleAssetName) &#123; mBundleAssetName = bundleAssetName; return this; &#125; public Builder setAssetDir(@NonNull final File assetDir) &#123; mAssetDir = assetDir; return this; &#125; public Builder setCallback(@Nullable final Callback callback) &#123; mCallback = callback; return this; &#125; public Builder setEnabled(@Nullable final Boolean enabled) &#123; mEnabled = enabled; return this; &#125; public JSBundleManager build() &#123; return new JSBundleManager(mBundleAssetName, mAssetDir, mCallback, mEnabled); &#125; &#125;&#125;简单来说，思路就是：当外部调用checkUpdate方法的时候，传进来的AppVersion是从服务端获取到的数据，包含bundle最新的版本号、是否需要更新和下载链接等信息。判断之后如果需要更新，那么就下载bundle到缓存中，如果成功下载，就把bundle复制到我这里自己定义热更新bundle的assetDir文件夹中，最后删除缓存中的bundle文件。至此，我的react-native热更新方案就结束了。欢迎大家互相讨论交流。]]></content>
      <categories>
        <category>hybrid</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native Android 初次踩坑之旅]]></title>
    <url>%2F2015%2F11%2F24%2FReact-native-Android-%E5%88%9D%E6%AC%A1%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[本文背景：项目要上线一个app内部通知中心的功能模块，UI比较简单，ListView为主。之前关注react-native一段时间，所以打算使用react-native踩坑，激进的来一把。本文目录如何把react-native集成到已经存在的Android studio工程中如何调试开发过程中踩过的那些坑Android打包过程中踩过的那些坑本文一切操作均在OS X系统上执行，调试手机为Android手机。如何把react-native集成到已经存在的Android studio工程中这部分主要参考官方文档Intergrating with Existing Apps内容，这里简述一下：导入react-native相关引用和权限1compile 'com.facebook.react:react-native:0.15.1'我开发的时候最新版本是0.15.1，如果想查看最新版本请戳Maven Central。然后在studio工程中的AndroidManifest.xml中加入1&lt;uses-permission android:name="android.permission.INTERNET" /&gt;在Android中支持晃动手机或点击菜单键打开react-native的调试页面，需要在AndroidManifest.xml中加入1&lt;activity android:name="com.facebook.react.devsupport.DevSettingsActivity" /&gt;react-natice需要app的build.gradle文件中配置compileSdkVersion为23，minSdkVersion为16，但是我们项目的appminSdkVersion为15，所以为了支持15，要修改app的build.gradle文件添加如下内容12345defaultConfig &#123; ndk &#123; abiFilters &quot;armeabi-v7a&quot; &#125;&#125;在AndroidManifext.xml中添加1&lt;uses-sdk tools:overrideLibrary=&quot;com.facebook.react&quot; /&gt;这时候可能会报一个ndk的错误，只要在gradle.properties中添加1android.useDeprecatedNdk=true即可。写好基础的Android原生和js代码这部分参照官方文档Intergrating with Existing Apps中的Add native code和Add JS to your app部分内容。最后官方还提出了如果想要在多个activity或fragment中使用react，需要把ReactInstanceManager用单例实现，这里我的实现很简单：1234567891011121314151617181920212223public class ReactInstanceManager &#123; public final static String MODULE_NAME = "CrowdReactApp"; private static class Holder &#123; private static ReactInstanceManager sInstance = ReactInstanceManager.builder() .setApplication((Application) ElemeApplicationContext.getContext()) .setBundleAssetName("index.android.bundle") .setJSMainModuleName("react-native/index.android") .addPackage(new MainReactPackage()) .addPackage(new CrowdReactPackage()) .setUseDeveloperSupport(BuildConfig.DEBUG) .setInitialLifecycleState(LifecycleState.RESUMED) .build(); &#125; private ReactInstanceManager() &#123; &#125; public static ReactInstanceManager getInstance() &#123; return Holder.sInstance; &#125;&#125;这里的index.android.bundle就是react部分打包生成好的文件，Android打包之后react部分就是根据这个文件来生成代码，热更新也是更换这个文件。react-native/index.android就是react-native目录下的index.android.js文件。这里我在app工程中新建了react-native文件夹，react代码都放入该文件夹中。Android原生模块和js部分拆分开发js部分我使用Sublime Text 3进行开发。这里简单讲讲我配置的简易插件：首先毫无疑问的就是Babel，支持es6语法高亮，在Sublime Text 3中安装请看babel-sublime。jsx的语法检查插件，参考esformatter-jsx，具体安装配置文档已经说的很清楚了，这里不再赘述。若想了解jsx请查看JSX in Depth。至此Android工程中已经集成好react-native模块了。如何调试在看这一部分之前，要保证上面一部分的内容已经非常仔细的执行完毕，否则一定会报错。尤其是对上面提到的官方文档部分的仔细研读。关于react-native的调试我们知道，实际上就是在本地起一个node server，然后当js文件有改动或debug模式下手动选择reload js时候会自动更新bundle文件，达到改动js文件后即时显示的调试效果。这里我没有用虚拟机调试，我直接使用真机调试。主要参考官方文档Running On Device部分，对于Android 5.0以上的手机，在USB调试模式下连接电脑runadb reverse tcp:8081 tcp:8081命令即可，晃动手机弹出调试窗口，选择reload js就可以看到效果。如果是Android5.0以下的手机，在晃动手机或者点击menu键弹出的react-native调试菜单中选择Dev Settings然后配置Debug server host &amp; port for device中配置你当前PC的ip地址加端口号即可，例如1127.0.0.1:8081端口号必须是8081，ip地址根据当前pc的ip地址填写，此时手机和PC必须在同一wifi下，如果用这种方式调试react-native，可以不插USB。在这个页面我们还可以看到一个选项叫Auto reload on JS change，如果我们选择它，就会在选项后面的小方框打勾，启动js改边自动更新的模式，这时候需要安装watchman才可以生效，如何安装1brew install watchman这里我是安装过homebrew的，如果没有安装的可以看Homebrew进行安装配置。调试部分内容到此结束。开发过程中踩的那些坑在开发之前，请务必仔细研读一篇非常优秀的博文React Native中组件的生命周期和官方文档中Native Modules，读懂之后再进行开发。我们知道，react的核心就是虚拟DOM，关于这部分网上介绍的文章太多了，在此不再赘述。这里主要以我用到的ListView控件和Image控件两大坑为主进行介绍，满满都是泪。首先是ListView的常规写法：12345678getInitialState: function() &#123; return &#123; dataSource: new ListView.DataSource(&#123; rowHasChanged: (row1, row2) =&gt; row1 !== row2, &#125;), loaded: false, &#125;; &#125;,我们需要了解的是，rowHasChanged中代码的意思是，当row1和row2不同时刷新Listview。这里的不同，是指引用不同，只是数据不同是不满足这个条件的。这是ListView的坑。说到引用不同，自然而然想到deepclone，Facebook自家提供了一个deepclone的高效解决方案Immutable。我项目中就用到了它，后面我会讲我是怎么用的。写代码的时候要注意一下，render中代码如果注释掉会报错的，其他部分的代码可以注释，但是render中的UI部分代码不能注释，要么就删掉，要么就保留。我们的逻辑应当是由数据来控制UI的显示，数据通过HTTP请求得到，那么免不了需要封装网络请求模块，这里我分享一下我是如何封装的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960'use strict';var NativeManagerAndroid = require('./NativeManagerAndroid');function RequestService() &#123; // Singleton pattern if (typeof RequestService.instance === 'object') &#123; return RequestService.instance; &#125; RequestService.instance = this;&#125;RequestService.prototype._httpHeader = function() &#123;return new Promise((resolve, reject) =&gt; &#123; NativeManagerAndroid.header((header) =&gt; &#123; resolve(header); &#125;);&#125;)&#125;RequestService.prototype.request = function(url, method, body) &#123;var isOk;return new Promise((resolve, reject) =&gt; &#123; this._httpHeader().then((header) =&gt; &#123; fetch(header.Host + url, &#123; method: method, headers: &#123; 'Content-Type': header.Content_Type, 'User-Agent': header.User_Agent, 'X-VERSION': header.X_VERSION, 'X-DEVICE': 1, //表示Android设备，iOS为2 'API-TIME': header.API_TIME, 'API-DEBUG': header.API_DEBUG, 'X-TOKEN': header.X_TOKEN, 'X-ID': header.X_ID, &#125;, body: body, &#125;) .then((response) =&gt; &#123; if (response.ok) &#123; isOk = true; &#125; else &#123; isOk = false; &#125; return response.json(); &#125;) .then((responseData) =&gt; &#123; if (isOk) &#123; resolve(responseData); &#125; else &#123; reject(responseData.message); &#125; &#125;) .catch((error) =&gt; &#123; reject(error); &#125;); &#125;);&#125;)&#125;;module.exports = RequestService;简单解释一下，这里的NativeManagerAndroid是我封装的Android原生模块的js部分，NativeManagerAndroid.header方法执行的是Android原生事先写好的header方法，关于这部分请再次仔细研读Native Modules，我这个方法主要是从原生代码中获取http的header，然后使用react-native自带的fetch进行http网络请求的封装。fetch返回的是promise，所以我利用了promise的特性进行封装，关于fetch and promise请仔细研读官方文档Network部分。注意：response.ok是HTTP CODE在200到300之间。module.exprots = RequestService是指把当前RequestService.js作为一个module，可以在其他js文件中引用。注意一下，如果用fetch执行put请求，必须有body，否则会crash，如果没有的话也要传一个空的body，像这样12var body = JSON.stringify(&#123;&#125;);关于react-native的StyleSheet部分，采用的是flexbox的样式，在开发之前请先阅读A Complete Guide to Flexbox。关于点击反馈，请查看官方文档COMPONENTS的TouchableHighlight，TouchableNativeFeedback，TouchableOpacity，TouchableWithoutFeedback。关于Immutable.js的使用，我代码中是这么用的12345678var newDs = [];newDs = this.state.ds.slice();notice.status = 1;var changeNotice = Immutable.Map(notice);newDs[rowID] = changeNotice.toObject();this.setState(&#123; dataSource: this.state.dataSource.cloneWithRows(newDs),&#125;);这段代码已经很好的解释了deepclone在这个模块里的用法，这时候dataSource的引用已经改变了。Immutable.js的运用远不止这么一点，具体还是要在项目中慢慢体会，仔细研读Immutable的官方文档。注意：这里的this.state.ds是每次从网上拉取新数据是本地的备份，参见12345678Request.request(NOTICE_LIST_URL, 'get') .then((noticeList) =&gt; &#123; this.setState(&#123; dataSource: this.state.dataSource.cloneWithRows(noticeList.notice_list), loaded: true, ds: noticeList.notice_list, &#125;); &#125;)load状态我是用来判断当前view是否展示loading界面还是listview界面。react的render机制，要么是state改变，要么是props改变，就会执行render进行UI刷新，我主要用到的是通过state来控制是否刷新UI。这里有个优化小技巧，我添加了这么一行代码1mixins: [React.addons.PureRenderMixin],这样可以减少不必要的render次数，具体参见React的官方文档PureRenderMixin。下面讲讲Image的坑。根据react-native的官方文档Image部分，如果需要加载本地静态资源（与Android原生共用图片资源），需要123&lt;Image source=&#123;require('image!myIcon')&#125;/&gt;但是，当工程跑起来之后，你会发现报了错：提示image!myIcon找不到。这里我反复google才发现2种解决方案：1.加载静态图片资源的方法与官网写法一致，启动node server时执行如下命令1react-native start --assetRoots ./android/app/src/main/res/在debug模式下就可以正常加载本地静态资源并进行调试了，但是在release打包后会crash，原因就是静态资源找不到，暂时没找到解决方案。2.加载静态图片资源的写法改为123&lt;Image source=&#123; &#123; uri: "myIcon", isStatic: true&#125; &#125;/&gt;启动node server时只要执行1react-native start即可。这种解决方案在Android release打包时同样有效，我目前就采用的这个解决方案。这是个大坑，花了好长时间才解决。在Android打包过程中踩过的那些坑首当其冲的是混淆，原生代码中所有自定义的ReactPackage和ReactContextBaseJavaModule等和reactjs部分配合使用的原生模块都必须keep掉，否则会crash，找不到原生的方法或类。这点我没在官方文档上找到说明，估计是Facebook觉得常识就应该这么做吧……Image静态资源问题上面已经讲到了，在打包过程中最后选取的解决方案，这是个坑。最后推荐开发过程中可以参考的一个项目ZhiHuDaily-React-Native，这个项目的作者也写了相关博客，很有用。踩坑还要继续，毕竟以前几乎没有写过js，也是小白，慢慢学习中，比较喜欢React，欢迎与我交流。]]></content>
      <categories>
        <category>hybrid</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将cordova集成到Android studio的最佳方法]]></title>
    <url>%2F2015%2F11%2F22%2F%E5%B0%86cordova%E9%9B%86%E6%88%90%E5%88%B0Android-studio%E7%9A%84%E6%9C%80%E4%BD%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[网上有很多集成cordova到Android studio中进行Android开发的方法，这里我给大家介绍一种比较简单的方法，亲测有效。目的首先我们明确目的，我们希望把cordova快速集成到Android studio中，为了以后的复用，我们希望做成jar或者aar，可以用于以后的项目，目的明确了，后面就一步一步来吧。cordova相关代码代码哪里来？大家不需要找，请看这里，将代码clone下来后发现有这么几个我们要用的文件夹：cordova-js-src：这部分是cordova-android对应的js代码，混合开发的时候H5需要将这个文件夹导入web工程，并做相应的引用和配置framework：这部分是cordova-android部分代码，需要全部拿过来test：这部分是测试工程，我们在集成好cordova后，还要根据测试工程实例进行相关配置，才能完全集成cordova到Android studio中进行hybrid开发。开始集成直接把framework模块打一个aar或jar包（我打的是aar）；把cordova-js-src复制到web工程中；结束。卧槽？这么简单？别激动，还没完，继续往下看。融合cordova到自己的工程中首先，我们建一个自己的Android工程，然后我们复制test工程中的/res/xml/config.xml文件到我们自己工程的/res/xml/config.xml中，不要改路径，然后修改config.xml文件：1234567891011121314151617181920212223242526&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;widget id="your package name" //包名 version="0.0.1"&gt; //版本号 &lt;content src="index.html" /&gt; &lt;feature name="xxxxx"&gt; //插件名 &lt;param name="android-package" value="your package name.xxxxx" /&gt; //插件路径 &lt;param name="onload" value="true" /&gt; &lt;/feature&gt; &lt;preference name="loglevel" value="DEBUG" /&gt; &lt;preference name="useBrowserHistory" value="true" /&gt; &lt;preference name="exit-on-suspend" value="false" /&gt; &lt;preference name="showTitle" value="true" /&gt;&lt;/widget&gt;极其重要的信息我已经做了注释，我想大家都能看懂，那就没问题了。这个配置文件是极其重要的，必须要有，切记切记！至此，集成就结束了。那么如何开发？我简单讲一下native这边需要做什么。Plugin：大家在上文中可以看到插件的配置，那么插件是什么？其实就是cordova提供给native和js通信的管道，我们需要自己实现一个插件类，参考这里AllowBridgeAccess：在插件类中，我们需要：1234@Override public Boolean shouldAllowBridgeAccess(String url) &#123; return true; &#125;这样我们的插件才可以被允许作为bridge（生效）。Lifecycle：为了后续布局的扩展，我没有选择extend CordovaActivity，那么我需要模仿CordovaActivity处理相关生命周期，这里我的布局很简单：12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/exam_home" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;org.apache.cordova.engine.SystemWebView android:id="@+id/cordovaWebView" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/LinearLayout&gt;然后我们看activity中的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126@ContentView(R.layout.activity_exam)public class ExamActivity extends BaseFragmentActivity &#123; private static final String EXAM_CENTER_URL = ""; //测试环境url private static final String EXAM_CENTER_URL_TEST = ""; private static final String ERROR_URL = "file:///android_asset/404.html"; @InjectView(R.id.cordovaWebView) protected SystemWebView webView; @InjectView(R.id.exam_home) protected LinearLayout examHome; private CordovaWebView cordovaWebView; protected CordovaInterfaceImpl cordovaInterface; private LoadingDialogFragment loading; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); init(); &#125; private void init() &#123; setTitle(R.string.drawer_examination); loading = LoadingDialogFragment.newInstance(false, getString(R.string.loading)); loading.setCancelable(false); initWebView(); loadExamCenterUrl(); &#125; private void initWebView() &#123; ConfigXmlParser parser = new ConfigXmlParser(); parser.parse(getActivity()); cordovaInterface = new CordovaInterfaceImpl(getActivity()) &#123; @Override public Object onMessage(String id, Object data) &#123; if ("onPageStarted".equals(id)) &#123; showRequestLoading(); return true; &#125; if ("onPageFinished".equals(id)) &#123; hideRequestLoading(); return true; &#125; if ("onReceivedError".equals(id)) &#123; cordovaWebView.loadUrl(ERROR_URL); return true; &#125; return super.onMessage(id, data); &#125; &#125;; if (NetworkUtils.isNetworkConnected(getActivity())) &#123; webView.getSettings().setCacheMode(WebSettings.LOAD_DEFAULT); &#125; else &#123; webView.getSettings().setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); &#125; cordovaWebView = new CordovaWebViewImpl(new SystemWebViewEngine(webView)); if (!cordovaWebView.isInitialized()) &#123; cordovaWebView.init(cordovaInterface, parser.getPluginEntries(), parser.getPreferences()); &#125; &#125; private void loadExamCenterUrl() &#123; if (AppConfig.isApkInDebug()) &#123; cordovaWebView.loadUrl(getExamCenterUrl(EXAM_CENTER_URL_TEST)); &#125; else &#123; cordovaWebView.loadUrl(getExamCenterUrl(EXAM_CENTER_URL)); &#125; &#125; private String getExamCenterUrl(String initUrl) &#123; return "http://www.baidu.com"; &#125; private void hideRequestLoading() &#123; synchronized (loading) &#123; loading.dismiss(); &#125; &#125; private void showRequestLoading() &#123; synchronized (loading) &#123; loading.show(getSupportFragmentManager()); &#125; &#125; @Override protected void onResume() &#123; super.onResume(); if (cordovaWebView != null) &#123; cordovaWebView.handleResume(true); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if (cordovaWebView != null) &#123; cordovaWebView.handlePause(true); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); examHome.removeView(webView); webView.removeAllViews(); if (cordovaWebView != null) &#123; cordovaWebView.handleDestroy(); &#125; &#125; @Override protected void onStart() &#123; super.onStart(); if (cordovaWebView != null) &#123; cordovaWebView.handleStart(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if (cordovaWebView != null) &#123; cordovaWebView.handleStop(); &#125; &#125;&#125;可以看出，这里对声明周期的处理模仿了CordovaActivity的生命周期，同时对基本native加载流程做了简单处理。尤其onDestory中的处理可以避免报webview.destory()的错误。这段代码适用于任何一个没有extend CordovaActivity进行cordova开发的activity。还有最最重要的一点：在正式打包apk的时候，一定要记得，在proguard-rules.pro文件中，去掉插件类的混淆，不能混淆插件类，否则打出来release包之后，进入混合开发的activity，会让你崩到爽……OK，就是这样了，有什么疑问欢迎大家交流。]]></content>
      <categories>
        <category>hybrid</category>
      </categories>
      <tags>
        <tag>cordova</tag>
      </tags>
  </entry>
</search>
